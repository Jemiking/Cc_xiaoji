# Slash Commands 使用指南

这套 slash commands 对应 sub-agents 体系,提供便捷的命令行入口启动各种开发任务。

## 📋 命令列表

### 🚀 完整流程

#### `/dev <需求描述>`
**完整的功能开发流程** - 从需求分析到代码实现的端到端流程

**执行阶段:**
1. **需求理解与调研** (并发 searcher + analyzer + architect)
2. **方案设计** (architect)
3. **代码实现** (并发多个 coder)
4. **质量保障** (并发 reviewer + tester + doc-writer)
5. **问题修复** (如需要: debugger + coder + tester)
6. **总结交付**

**示例:**
```
/dev 实现用户登录功能
/dev 添加文件上传功能,支持拖拽和进度显示
```

**输出:**
- ✅ 功能代码
- ✅ 测试代码
- ✅ API 文档
- ✅ 代码审查报告

---

### 🔍 信息检索层

#### `/search <搜索内容>`
**代码检索** - 快速定位相关代码和功能

调用: **searcher** agent

**示例:**
```
/search 用户认证相关代码
/search 文件上传功能
/search JWT token 生成
```

**输出:**
- 核心文件列表(文件路径:行号)
- 相关依赖文件
- 配置文件
- 关键代码片段

---

#### `/analyze <分析目标>`
**代码分析** - 深入理解代码架构和设计

调用: **analyzer** agent

**示例:**
```
/analyze 用户模块的架构设计
/analyze 整个项目的技术栈和依赖
/analyze 认证系统的设计模式
```

**输出:**
- 项目概览(技术栈、架构模式)
- 目录结构分析
- 核心模块分析
- 依赖关系图
- 代码质量评估
- 改进建议

---

### 🏗️ 规划设计层

#### `/plan <需求描述>`
**架构规划** - 将需求转化为技术方案

调用: **architect** agent

**示例:**
```
/plan 设计一个用户权限系统
/plan 实现实时通知功能的技术方案
/plan 添加多语言支持
```

**输出:**
- 详细技术方案文档
  - 需求概述
  - 技术选型(语言/框架/库/模式)
  - 架构设计(模块/流程/数据流)
  - 接口设计
  - 错误处理策略
  - 测试策略
  - 风险评估
- 实施任务清单(标注并发/串行)

---

### 💻 代码实现层

#### `/implement <实现内容>`
**代码实现** - 编写高质量的功能代码

调用: **coder** agent

**示例:**
```
/implement 用户登录逻辑
/implement 文件上传 API 接口
/implement 数据验证中间件
```

**输出:**
- 创建/修改的文件列表
- 核心实现说明
- 使用方式和集成指南
- 注意事项

**特点:**
- ✅ 遵循项目规范
- ✅ 完整的类型定义
- ✅ 完善的错误处理
- ✅ 适当的代码注释

---

#### `/refactor <重构目标>`
**代码重构** - 优化代码结构和性能

调用: **refactor** agent

**示例:**
```
/refactor 优化用户查询的性能
/refactor 重构认证模块,消除重复代码
/refactor 简化复杂的订单处理逻辑
```

**输出:**
- 重构报告
  - 重构目标和范围
  - 重构内容详情
  - 改进效果(行数/复杂度/性能对比)
  - 风险评估
  - 后续建议

**特点:**
- ✅ 小步重构,频繁验证
- ✅ 保持功能不变
- ✅ 确保测试通过
- ✅ 性能改进量化

---

### ✅ 质量保障层

#### `/review <审查目标>`
**代码审查** - 多维度质量检查

调用: **reviewer** agent

**示例:**
```
/review 审查最新提交的用户模块代码
/review 检查 src/services/auth.service.ts 的安全性
/review 审查 PR #123 的代码质量
```

**输出:**
- 代码审查报告
  - 审查概述(范围、规模、总体评价)
  - 🔴 **重大问题** (必须修复)
  - 🟡 **需要改进** (强烈建议)
  - 🟢 **优化建议** (可选)
  - ✅ **值得学习** (好的实践)
  - 审查清单(6个维度全覆盖)

**审查维度:**
- 功能正确性
- 代码质量
- 性能
- 安全性
- 可测试性
- 代码规范

---

#### `/test <测试目标>`
**测试编写** - 设计测试用例并编写测试代码

调用: **tester** agent

**示例:**
```
/test 为用户登录功能编写测试
/test 添加 API 端点的集成测试
/test 编写组件的单元测试
```

**输出:**
- 测试报告
  - 测试用例数和通过率
  - 测试覆盖率详情
  - 失败测试的修复建议
  - 未覆盖代码的补充建议

**测试类型:**
- 单元测试 (Unit Test)
- 集成测试 (Integration Test)
- 端到端测试 (E2E Test)

---

### 🐛 问题诊断层

#### `/debug <问题描述>`
**问题诊断** - 定位 Bug 根因并提供修复方案

调用: **debugger** agent

**示例:**
```
/debug 登录时报错 "Cannot read property 'name' of undefined"
/debug 用户列表加载很慢,需要优化性能
/debug 文件上传失败,返回 500 错误
```

**输出:**
- 问题诊断报告
  - 问题概述(错误类型、信息、影响、严重程度)
  - 错误位置(文件:行号、函数、调用链)
  - 根本原因(5个为什么分析)
  - 复现步骤
  - 多个修复方案对比
  - 推荐方案及理由
  - 预防措施
  - 影响评估

---

### 📝 文档层

#### `/doc <文档目标>`
**文档编写** - 生成清晰的技术文档

调用: **doc-writer** agent

**示例:**
```
/doc 为用户 API 编写文档
/doc 生成项目 README
/doc 为复杂函数添加 JSDoc 注释
```

**输出:**
- 创建/更新的文档列表
- 文档概要
- 后续维护建议

**文档类型:**
- API 文档 (JSDoc/TSDoc)
- 使用指南 (README.md)
- 架构文档 (ARCHITECTURE.md)
- 代码注释

---

## 🔄 并发工作流示例

### 示例 1: 实现新功能(使用 /dev)

```
你: /dev 实现用户注册功能

Claude:
阶段1 (并发): searcher + analyzer + architect 调研
阶段2: architect 设计方案
阶段3 (并发): coder 实现多个模块
阶段4 (并发): reviewer + tester + doc-writer 质量保障
```

### 示例 2: 手动控制流程

```
# 第1步: 先调研
你: /search 现有的用户认证代码
你: /analyze 用户模块的架构

# 第2步: 规划方案
你: /plan 添加双因素认证功能

# 第3步: 实现
你: /implement 双因素认证逻辑

# 第4步: 质量保障
你: /review 审查双因素认证代码
你: /test 为双因素认证编写测试
你: /doc 编写双因素认证 API 文档
```

### 示例 3: 问题修复

```
# 第1步: 诊断问题
你: /debug 登录接口返回 500 错误

# 第2步: 修复代码
你: /implement 修复登录错误处理逻辑

# 第3步: 验证修复
你: /test 添加登录错误场景的测试
你: /review 审查修复代码
```

### 示例 4: 代码优化

```
# 第1步: 分析现状
你: /analyze 用户查询模块的性能

# 第2步: 重构优化
你: /refactor 优化用户查询性能

# 第3步: 验证改进
你: /test 运行性能测试验证改进
你: /review 审查重构代码
```

---

## 💡 使用技巧

### 1. 根据任务选择合适的命令

**快速开发** → 使用 `/dev` 完整流程

**精细控制** → 组合使用单个命令

**代码调研** → `/search` + `/analyze`

**需求澄清** → `/plan`

**Bug 修复** → `/debug` + `/implement` + `/test`

### 2. 命令组合策略

**并发执行** (同时发送多个命令):
```
/search 用户认证代码
/analyze 认证模块架构
```

**串行执行** (等待前一个完成):
```
/plan 设计方案
等待方案输出后...
/implement 根据方案实现
```

### 3. 参数传递

命令后的所有内容都会作为参数传递给 agent:

```
/search 用户认证相关的所有代码,包括 JWT 和 OAuth
/implement 创建用户注册接口,需要邮箱验证和密码强度检查
/debug 用户列表分页功能在数据量大时很慢,需要优化
```

### 4. 结合主对话

命令只是启动 agents 的快捷方式,你仍然可以:
- 在主对话中提供更多上下文
- 与 agents 的输出交互
- 根据输出结果调整下一步

---

## 📊 命令 vs Agent 对应关系

| 命令 | Agent | 工具权限 | 并发能力 |
|------|-------|---------|---------|
| `/search` | searcher | 只读 | ✅ |
| `/analyze` | analyzer | 只读 | ✅ |
| `/plan` | architect | 只读 + Task | 可调用其他 |
| `/implement` | coder | 读写 | ✅ |
| `/refactor` | refactor | 读写 + Task | 可调用其他 |
| `/review` | reviewer | 只读 + Task | ✅ |
| `/test` | tester | 读写 + Task | ✅ |
| `/debug` | debugger | 只读 + Task | 可调用其他 |
| `/doc` | doc-writer | 读写 + Task | ✅ |
| `/dev` | 多个 agents | 综合 | 多阶段并发 |

---

## 🎯 最佳实践

1. **明确描述**: 提供清晰具体的需求描述
2. **适当粒度**: 任务不要太大也不要太小
3. **并发优先**: 能并发的任务尽量并发执行
4. **及时验证**: 每个阶段完成后检查结果
5. **遵循流程**: 对于复杂任务使用 `/dev` 标准流程

---

**现在就开始使用这些命令,体验高效的并发开发工作流! 🚀**
