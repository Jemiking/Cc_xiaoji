代码重构 - 优化代码结构和性能

Arguments: $ARGUMENTS

## 🔧 代码重构任务

调用 **refactor** agent 在保持功能不变的前提下优化代码。

## 重构目标

**重构内容**: $ARGUMENTS

## 执行流程

我将调用 **refactor** agent 执行重构任务:

### 阶段 1: 分析现状

**1.1 理解重构目标**
- 要解决什么问题?(性能/可读性/重复代码/技术债务)
- 重构范围是什么?
- 成功标准是什么?

**1.2 分析现有代码**
- 调用 analyzer 分析代码结构和复杂度
- 调用 searcher 查找所有相关代码
- 评估重构影响范围

**1.3 制定重构方案**
- 重构步骤(小步快跑)
- 风险评估
- 回滚策略
- 验证方法

### 阶段 2: 重构实施

**重构原则:**

**小步重构**
- ✅ 每次只做一个小改动
- ✅ 每步都保持代码可运行
- ✅ 频繁测试验证
- ❌ 不要大规模重写
- ❌ 不要同时改多个东西

**保持功能不变**
- ✅ 重构只改结构,不改行为
- ✅ 保持对外接口不变(或兼容)
- ✅ 保持测试通过
- ❌ 不要在重构时加新功能

**常见重构模式:**

1. **提取函数** - 将复杂函数拆分成小函数
2. **提取类/模块** - 将职责分离
3. **消除重复代码** - 提取公共逻辑
4. **简化条件表达式** - 使用策略模式等
5. **性能优化** - 缓存、批量操作、并发

### 阶段 3: 质量验证

**步骤1: 确保有测试**
- 如果没有测试,先编写测试
- 调用 tester 补充测试覆盖
- 确保测试通过

**步骤2: 小步重构**
每一步:
1. 做一个小改动
2. 运行测试
3. 确保通过
4. 提交(如果使用 git)
5. 继续下一步

**步骤3: 验证结果**
- ✅ 所有测试通过
- ✅ 功能行为不变
- ✅ 性能没有下降(或有提升)
- ✅ 代码更清晰易懂

### 阶段 4: 输出重构报告

报告内容:
- 重构目标和范围
- 重构内容详情
- 改进效果(行数/复杂度/性能)
- 风险评估
- 后续建议

## 重构时机

**✅ 适合重构:**
- 代码重复出现 3 次以上
- 函数超过 50 行
- 函数参数超过 4 个
- 嵌套超过 3 层
- 发现性能瓶颈

**⚠️ 谨慎重构:**
- 临近发布时
- 没有测试覆盖
- 不熟悉的代码
- 核心关键路径

## 预期输出

```markdown
## 重构报告

### 重构目标
[描述要解决的问题]

### 重构范围
- 文件1: src/services/user.service.ts
- 文件2: src/utils/validation.ts

### 重构内容

#### 1. 提取函数
- 将 `processUser` 中的验证逻辑提取为 `validateUserInput`
- 将计算逻辑提取为 `calculateUserScore`

#### 2. 消除重复
- 提取公共的错误处理逻辑到 `handleServiceError`
- 统一使用 `logger.error` 记录错误

#### 3. 性能优化
- 将 N 次数据库查询合并为 1 次批量查询
- 添加缓存减少重复计算

### 改进效果

✅ 代码行数: 500 → 350 (减少 30%)
✅ 函数平均复杂度: 降低 40%
✅ 响应时间: 500ms → 200ms (提升 60%)
✅ 测试覆盖率: 保持 95%

### 风险评估
⚠️ 低风险: 所有测试通过,行为未改变

### 后续建议
- [ ] 继续优化 XXX 模块
- [ ] 添加更多单元测试
```

## 重构清单

```markdown
## 重构前检查
- [ ] 理解当前代码的行为
- [ ] 确认有测试覆盖(或先写测试)
- [ ] 运行测试确保通过
- [ ] 识别重构范围和影响

## 重构中检查
- [ ] 每次只做一个小改动
- [ ] 每步改动后运行测试
- [ ] 保持代码可运行状态
- [ ] 频繁提交(如使用 git)

## 重构后检查
- [ ] 所有测试通过
- [ ] 功能行为未改变
- [ ] 性能未下降
- [ ] 代码更清晰易懂
- [ ] 无新增技术债务
```

## 八荣八耻

- ✅ 以回头校验为荣,以一遍通过为耻
- ✅ 以谨慎重构为荣,以盲目修改为耻
- ✅ 以遵循规范为荣,以破坏架构为耻

## 开始重构

现在调用 refactor agent 开始代码重构...
