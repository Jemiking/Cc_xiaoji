# 方案二执行步骤：统一分类管理

> 创建日期：2025-07-05
> 目标：将分类管理统一到 CategoryRepository
> 挑战：处理已有数据的升级

## 执行步骤

### Step 1: 扩展 CategoryRepository 接口
```kotlin
// feature/ledger/src/.../domain/repository/CategoryRepository.kt
interface CategoryRepository {
    // ... 现有方法
    
    /**
     * 初始化或升级默认分类
     * @return 新创建的分类数量
     */
    suspend fun initializeOrUpgradeDefaultCategories(): Int
}
```

### Step 2: 改造 CategoryRepositoryImpl
```kotlin
// feature/ledger/src/.../data/repository/CategoryRepositoryImpl.kt

// 1. 添加完整的默认分类定义
companion object {
    private val DEFAULT_CATEGORIES = listOf(
        // 支出分类（10个）
        DefaultCategory("餐饮", "🍜", "#FF6B6B", Category.Type.EXPENSE, 1),
        DefaultCategory("交通", "🚇", "#4ECDC4", Category.Type.EXPENSE, 2),
        DefaultCategory("购物", "🛍️", "#45B7D1", Category.Type.EXPENSE, 3),
        DefaultCategory("娱乐", "🎮", "#F7DC6F", Category.Type.EXPENSE, 4),
        DefaultCategory("医疗", "🏥", "#E74C3C", Category.Type.EXPENSE, 5),
        DefaultCategory("教育", "📚", "#3498DB", Category.Type.EXPENSE, 6),
        DefaultCategory("居住", "🏠", "#9B59B6", Category.Type.EXPENSE, 7),
        DefaultCategory("水电", "💡", "#1ABC9C", Category.Type.EXPENSE, 8),
        DefaultCategory("通讯", "📱", "#34495E", Category.Type.EXPENSE, 9),
        DefaultCategory("其他", "📌", "#95A5A6", Category.Type.EXPENSE, 10),
        
        // 收入分类（5个）
        DefaultCategory("工资", "💰", "#27AE60", Category.Type.INCOME, 1),
        DefaultCategory("奖金", "🎁", "#F39C12", Category.Type.INCOME, 2),
        DefaultCategory("投资", "📈", "#8E44AD", Category.Type.INCOME, 3),
        DefaultCategory("兼职", "💼", "#2980B9", Category.Type.INCOME, 4),
        DefaultCategory("其他", "💸", "#16A085", Category.Type.INCOME, 5)
    )
}

// 2. 实现智能升级方法
override suspend fun initializeOrUpgradeDefaultCategories(): Int {
    val userId = userApi.getCurrentUserId()
    val existingCategories = categoryDao.getCategoriesByUser(userId).first()
    
    // 构建现有分类的索引（name+type作为唯一标识）
    val existingIndex = existingCategories
        .filter { it.isSystem } // 只考虑系统分类
        .map { "${it.name}_${it.type}" }
        .toSet()
    
    // 找出缺失的分类
    val missingCategories = DEFAULT_CATEGORIES.filter { default ->
        "${default.name}_${default.type.name}" !in existingIndex
    }
    
    // 创建缺失的分类
    if (missingCategories.isNotEmpty()) {
        val timestamp = System.currentTimeMillis()
        val newEntities = missingCategories.map { default ->
            CategoryEntity(
                id = UUID.randomUUID().toString(),
                userId = userId,
                name = default.name,
                icon = default.icon,
                color = default.color,
                type = default.type.name,
                displayOrder = default.order,
                isSystem = true,
                createdAt = timestamp,
                updatedAt = timestamp
            )
        }
        categoryDao.insertCategories(newEntities)
    }
    
    return missingCategories.size
}

// 3. 数据类定义
private data class DefaultCategory(
    val name: String,
    val icon: String,
    val color: String,
    val type: Category.Type,
    val order: Int
)
```

### Step 3: 修改 CcXiaoJiApplication
```kotlin
// app/src/main/java/com/ccxiaoji/app/CcXiaoJiApplication.kt

@HiltAndroidApp
class CcXiaoJiApplication : Application(), Configuration.Provider {
    
    // ... 现有注入
    
    @Inject
    lateinit var categoryRepository: CategoryRepository
    
    override fun onCreate() {
        super.onCreate()
        
        CoroutineScope(Dispatchers.IO).launch {
            try {
                // ... 现有的用户和账户初始化
                
                // 使用 CategoryRepository 初始化分类
                val createdCount = categoryRepository.initializeOrUpgradeDefaultCategories()
                if (createdCount > 0) {
                    Log.d(TAG, "Created $createdCount new default categories")
                } else {
                    Log.d(TAG, "All default categories already exist")
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Error during initialization", e)
            }
        }
    }
    
    // 删除 createDefaultCategories 方法
}
```

### Step 4: 处理边界情况

#### 4.1 防止竞态条件
```kotlin
// 使用事务确保原子性
@Transaction
suspend fun initializeOrUpgradeDefaultCategories(): Int {
    // ... 实现
}
```

#### 4.2 版本管理（可选）
```kotlin
// 在 DataStore 中记录分类版本
@Singleton
class CategoryVersionManager @Inject constructor(
    private val dataStore: DataStore<Preferences>
) {
    companion object {
        val CATEGORY_VERSION_KEY = intPreferencesKey("category_version")
        const val CURRENT_VERSION = 2 // 15个分类
    }
    
    suspend fun shouldUpgrade(): Boolean {
        val currentVersion = dataStore.data.first()[CATEGORY_VERSION_KEY] ?: 0
        return currentVersion < CURRENT_VERSION
    }
    
    suspend fun markAsUpgraded() {
        dataStore.edit { it[CATEGORY_VERSION_KEY] = CURRENT_VERSION }
    }
}
```

### Step 5: 测试计划

1. **单元测试**
```kotlin
@Test
fun `test category upgrade from 8 to 15`() {
    // 1. 创建8个分类
    // 2. 调用 initializeOrUpgradeDefaultCategories
    // 3. 验证总共有15个分类
    // 4. 验证没有重复
}
```

2. **集成测试**
```kotlin
@Test
fun `test multiple calls are idempotent`() {
    // 1. 调用两次 initializeOrUpgradeDefaultCategories
    // 2. 验证分类数量仍为15
}
```

## 优势分析

### ✅ 优点
1. **统一管理**：所有分类定义在一处
2. **智能升级**：自动检测并添加缺失分类
3. **无重复风险**：基于名称+类型去重
4. **可重复执行**：多次调用安全
5. **易于维护**：未来添加新分类只需修改一处

### ⚠️ 注意事项
1. **依赖注入时序**：确保 Repository 在 Application 中可用
2. **数据库事务**：使用事务保证原子性
3. **性能考虑**：只在启动时执行一次

## 执行时间表

| 步骤 | 工作内容 | 预计时间 |
|------|---------|----------|
| 1 | 修改接口和实现 | 30分钟 |
| 2 | 修改Application | 15分钟 |
| 3 | 编写测试 | 45分钟 |
| 4 | 测试验证 | 30分钟 |
| **总计** | | **2小时** |

## 回滚方案

如果出现问题，可以：
1. 保留原有的 createDefaultCategories 方法
2. 在 feature flag 后面切换新旧逻辑
3. 通过版本控制快速回滚

---
*设计时间：2025-07-05*