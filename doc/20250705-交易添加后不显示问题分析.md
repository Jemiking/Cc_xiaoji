# 交易添加后不显示问题分析

> 创建日期：2025-07-05
> 问题状态：已定位 ✅
> 影响范围：记账模块交易列表刷新

## 问题描述
用户添加新交易后，交易列表不会立即显示新增的交易，需要重启app才能看到。

## 问题分析

### 1. 根本原因
在 `LedgerViewModel.addTransaction` 方法中，添加交易后**没有调用 `loadTransactions()` 刷新列表**。

```kotlin
fun addTransaction(...) = launch {
    val finalAccountId = accountId ?: _uiState.value.selectedAccountId 
        ?: _uiState.value.accounts.firstOrNull()?.id ?: return@launch
    runCatching {
        addTransactionUseCase(amountCents, categoryId, note, finalAccountId)
        checkBudget(categoryId, onBudgetAlert)
        loadMonthlySummary()
        // ❌ 缺少: loadTransactions()
    }
}
```

### 2. 技术背景
#### 分页查询不是响应式的
- `TransactionDao.getTransactionsPaginated` 是 `suspend` 函数，不是返回 Flow
- `TransactionRepositoryImpl.getTransactionsPaginated` 使用 `flow { emit(...) }` 只发射一次数据
- 这不是响应式的数据流，不会自动监听数据库变化

```kotlin
// 当前实现 - 一次性查询
override fun getTransactionsPaginated(...): Flow<BaseResult<Pair<List<Transaction>, Int>>> = flow {
    try {
        val result = transactionDao.getTransactionsPaginated(...)
        // 只发射一次数据就结束
        emit(BaseResult.Success(Pair(transactions, result.second)))
    } catch (e: Exception) {
        emit(BaseResult.Error(e))
    }
}
```

#### 对比：其他方法是响应式的
```kotlin
// 响应式查询 - 持续监听数据库变化
@Query("SELECT * FROM transactions WHERE userId = :userId ...")
fun getTransactionsByUser(userId: String): Flow<List<TransactionEntity>>
```

### 3. 相关代码位置
- **ViewModel**: `/feature/ledger/src/.../viewmodel/LedgerViewModel.kt` (第107-118行)
- **UseCase**: `/feature/ledger/src/.../usecase/GetPaginatedTransactionsUseCase.kt`
- **Repository**: `/feature/ledger/src/.../repository/TransactionRepositoryImpl.kt` (第316-350行)
- **DAO**: `/feature/ledger/src/.../dao/TransactionDao.kt` (第135-165行)

## 解决方案

### 方案一：快速修复（推荐）
在 `addTransaction` 方法中添加 `loadTransactions()` 调用：

```kotlin
fun addTransaction(
    amountCents: Int, categoryId: String, note: String?, 
    accountId: String? = null, onBudgetAlert: (String, Boolean) -> Unit = { _, _ -> }
) = launch {
    val finalAccountId = accountId ?: _uiState.value.selectedAccountId 
        ?: _uiState.value.accounts.firstOrNull()?.id ?: return@launch
    runCatching {
        addTransactionUseCase(amountCents, categoryId, note, finalAccountId)
        checkBudget(categoryId, onBudgetAlert)
        loadMonthlySummary()
        loadTransactions()  // ✅ 添加这一行
    }
}
```

**优点**：
- 简单直接
- 最小改动
- 立即生效

**缺点**：
- 需要手动刷新
- 不是真正的响应式

### 方案二：响应式改造（长期方案）
使分页查询支持响应式数据流：

1. **修改 DAO**：返回 Flow 而不是 suspend 函数
```kotlin
@Query("""
    SELECT * FROM transactions 
    WHERE userId = :userId AND isDeleted = 0
    AND (:accountId IS NULL OR accountId = :accountId)
    AND (:startDateMillis IS NULL OR createdAt >= :startDateMillis)
    AND (:endDateMillis IS NULL OR createdAt <= :endDateMillis)
    ORDER BY createdAt DESC 
    LIMIT :limit OFFSET :offset
""")
fun getTransactionsPaginatedFlow(
    userId: String,
    offset: Int,
    limit: Int,
    accountId: String?,
    startDateMillis: Long?,
    endDateMillis: Long?
): Flow<List<TransactionEntity>>
```

2. **修改 Repository**：转换为持续的 Flow
```kotlin
override fun getTransactionsPaginated(...): Flow<BaseResult<Pair<List<Transaction>, Int>>> {
    return transactionDao.getTransactionsPaginatedFlow(...)
        .map { entities ->
            // 转换数据并返回
            BaseResult.Success(Pair(transactions, totalCount))
        }
        .catch { e ->
            emit(BaseResult.Error(e))
        }
}
```

**优点**：
- 真正的响应式
- 自动更新UI
- 更好的用户体验

**缺点**：
- 改动较大
- 需要处理分页的复杂性

### 方案三：混合方案
保持现有架构，但在关键操作后主动刷新：

```kotlin
// 在 ViewModel 中添加事件监听
private val _refreshTrigger = MutableSharedFlow<Unit>()

init {
    // 监听刷新事件
    _refreshTrigger
        .onEach { loadTransactions() }
        .launchIn(viewModelScope)
}

fun addTransaction(...) = launch {
    runCatching {
        addTransactionUseCase(...)
        _refreshTrigger.emit(Unit)  // 触发刷新
    }
}
```

## 验证方法
1. 应用修复后编译运行
2. 添加新交易
3. 检查交易列表是否立即显示新交易
4. 不需要重启app

## 其他发现
`copyTransaction` 方法正确调用了 `loadTransactions()`，这说明开发者意识到需要刷新，但在 `addTransaction` 中遗漏了。

---
*分析时间：2025-07-05*