# 返回上一步问题修复方案（Ledger 导航）

## 背景与目标
- 背景：当前返回行为不一致，出现以下问题：
  - 从外部/深链直接进入某些页面（如“添加交易”）时，点返回可能直接退出或无反应，无法回到上一级（记账首页）。
  - 记账首页（LedgerScreen）顶部为抽屉入口，无“统一系统返回”处理；在抽屉打开/搜索模式/选择模式下，系统返回键未优先处理这些状态。
  - 页面间普遍直接使用 `popBackStack()`/`navigateUp()`，未定义“无栈时的兜底父级”。
- 目标：
  - 明确“父级页面”并建立“智能返回”策略：优先 `popBackStack()`，失败时回退到约定父级路由。
  - 记账首页按返回时应该回到 App 首页；记账模块的子页面按返回时应回到记账首页。
  - 抽屉/搜索模式/选择模式优先退出其状态，再进行路由回退。
  - 建立标准化、可复用的返回处理方案，便于后续模块复用。

## 设计原则
1) 一致的父级：
   - 记账首页（Ledger root）父级 = App 首页（`Screen.Home.route`）。
   - 记账子页（添加/编辑/筛选/详情/管理等）父级 = 记账首页（`Screen.Ledger.route`）。
2) 优先关闭状态：若抽屉打开/处于搜索模式/选择模式，先退出这些状态；否则再执行导航回退。
3) 智能返回策略：
   - 先 `popBackStack()`/`navigateUp()`；
   - 若返回失败（无可退栈），则 `navigate(fallbackRoute)`；
   - 避免“清栈返回”，除非明确需要；尽量保持“逐层返回”的直觉。

## 技术方案

### 1. 引入 NavController 扩展：智能返回
新增扩展函数（App 模块）：`NavigationExtensions.kt`

```kotlin
package com.ccxiaoji.app.presentation.ui.navigation

import androidx.navigation.NavController
import androidx.navigation.NavGraph.Companion.findStartDestination

fun NavController.smartBack(fallbackRoute: String) {
    val popped = try { popBackStack() } catch (_: Throwable) { false }
    if (!popped) {
        navigate(fallbackRoute) {
            // 防止重复叠加同一路由
            launchSingleTop = true
            restoreState = true
            // 不做清栈，保持“逐层返回”的体验
        }
    }
}

fun NavController.smartBackToHome() {
    smartBack(Screen.Home.route)
}

fun NavController.smartBackToLedger() {
    smartBack(Screen.Ledger.route)
}
```

说明：
- 统一封装“先 pop 再兜底 navigate”的逻辑，避免页面直接“猜测父级”。
- 将兜底路由集中到 App 层（掌握全局路由常量），Feature 模块通过回调获益。

### 2. 标准化屏幕返回回调：onNavigateBack（可选参数）
- 为需要“自带返回按钮”的页面增加可选参数：`onNavigateBack: (() -> Unit)? = null`。
- 页面内部的 TopBar 左上角返回按钮优先调用 `onNavigateBack?.invoke()`；若为 `null`，降级为 `navController.navigateUp()`（保留默认行为）。
- 好处：父级（App 的 `NavGraph`）根据上下文传入合适的“智能返回策略”（回到 Ledger 或回到 Home），Feature 不需知道上层路由常量。

需要新增该参数的页面（优先级从高到低）：
- `feature/ledger/.../transaction/AddTransactionScreen.kt`
- `feature/ledger/.../transaction/EditTransactionScreen.kt`
- `feature/ledger/.../transaction/FilterTransactionScreen.kt`
- `feature/ledger/.../transaction/TransactionDetailScreen.kt`
- （可选/按需）`feature/ledger/.../account/*`、`.../budget/*`、`.../category/*` 等带返回按钮的页面

示例（以 AddTransactionScreen 为例，伪代码变更点）：
```kotlin
@Composable
fun AddTransactionScreen(
    navController: NavController,
    transactionId: String? = null,
    onNavigateBack: (() -> Unit)? = null,
    ...
) {
    // 顶部返回按钮
    IconButton(onClick = { onNavigateBack?.invoke() ?: navController.navigateUp() }) {
        Icon(Icons.AutoMirrored.Filled.ArrowBack, ...)
    }
}
```

### 3. LedgerScreen 增强系统返回处理（BackHandler）
- 为 `LedgerScreen` 新增可选参数 `onBack: (() -> Unit)? = null`；在 Compose 中使用 `BackHandler` 实现如下优先级：
  1) 若抽屉打开：关闭抽屉。
  2) 若处于搜索模式：退出搜索模式并清空搜索。
  3) 若处于选择模式：退出选择模式。
  4) 否则：调用 `onBack?.invoke()`；若为 `null`，降级为 `navController.popBackStack()`。
- App 侧（`NavGraph.kt`）在 Ledger 路由处传入：`onBack = { navController.smartBackToHome() }`。
- 注：需引入 `androidx.activity.compose.BackHandler` 依赖（一般已存在）。

示例（伪代码变更点）：
```kotlin
@Composable
fun LedgerScreen(
    navController: NavController? = null,
    onBack: (() -> Unit)? = null,
    ...
) {
    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
    val selectionState by selectionViewModel.selectionState.collectAsState()
    val searchState by searchViewModel.searchState.collectAsState()

    BackHandler {
        when {
            drawerState.isOpen -> coroutineScope.launch { drawerState.close() }
            searchState.isSearchMode -> { searchViewModel.toggleSearchMode(); searchViewModel.clearSearch() }
            selectionState.isSelectionMode -> selectionViewModel.toggleSelectionMode()
            else -> onBack?.invoke() ?: navController?.popBackStack()
        }
    }
}
```

### 4. App NavGraph 统一接线
- 在 `NavGraph.kt` 中为各 Ledger 子路由传入对应的“智能返回”回调：

```kotlin
// 记账首页（父级：Home）
composable(Screen.Ledger.route) {
    ledgerApi.getLedgerScreen(
        navController = navController,
        accountId = null,
        onBack = { navController.smartBackToHome() }
    )
}

// 添加交易（父级：Ledger）
composable(AddTransactionRoute.route) { backStackEntry ->
    val transactionId = backStackEntry.arguments?.getString("transactionId")
    com.ccxiaoji.feature.ledger.presentation.screen.transaction.AddTransactionScreen(
        navController = navController,
        transactionId = transactionId,
        onNavigateBack = { navController.smartBackToLedger() }
    )
}

// 编辑交易 / 筛选 / 详情等同理：传入 smartBackToLedger()
```

说明：
- 记账首页（Ledger root）回到 Home；其它子页回到 Ledger。
- 对已有的 `onNavigateBack = { navController.popBackStack() }` 逐步替换为 `smartBack...()`。

### 5. LedgerApi 接口扩展（必要时）
- 若需要从 App 侧为 `LedgerScreen` 传入 `onBack`，可将 `LedgerApi.getLedgerScreen(...)` 签名扩展：

```kotlin
// interface LedgerApi
fun getLedgerScreen(
    navController: NavHostController,
    accountId: String?,
    onBack: (() -> Unit)? = null
)

// impl 内部调用 LedgerScreen(..., onBack = onBack)
```

> 注：此改动会影响 app 与 feature 的接口契约，需要同时修改 `LedgerApi.kt`、`LedgerApiImpl.kt` 与 `NavGraph.kt` 的调用处。

### 6. 依赖与兼容性
- 需要保证依赖：`androidx.activity:activity-compose`（用于 `BackHandler`）。
- 本方案不引入清栈式返回（`popUpTo(...){ inclusive = true }`），以保证“逐层返回”体验稳定。

## 变更清单（文件级）
1) [新增] `app/src/main/java/com/ccxiaoji/app/presentation/ui/navigation/NavigationExtensions.kt`
   - `NavController.smartBack(fallbackRoute: String)`
   - `NavController.smartBackToHome()` / `smartBackToLedger()`

2) [修改] `feature/ledger/.../ledger/LedgerScreen.kt`
   - 新增参数：`onBack: (() -> Unit)? = null`
   - 新增 `BackHandler`，按优先级处理抽屉/搜索/选择/智能返回

3) [修改] `feature/ledger/.../transaction/AddTransactionScreen.kt`
   - 新增参数：`onNavigateBack: (() -> Unit)? = null`
   - TopBar 返回调用：`onNavigateBack?.invoke() ?: navController.navigateUp()`
   - （可选）`BackHandler { onNavigateBack?.invoke() ?: navController.navigateUp() }`

4) [修改] `feature/ledger/.../transaction/EditTransactionScreen.kt`
   - 同 AddTransactionScreen 处理

5) [修改] `feature/ledger/.../transaction/FilterTransactionScreen.kt`
   - 同 AddTransactionScreen 处理

6) [修改] `feature/ledger/.../transaction/TransactionDetailScreen.kt`
   - 同 AddTransactionScreen 处理

7) [修改] `app/src/main/java/com/ccxiaoji/app/presentation/ui/navigation/NavGraph.kt`
   - 在 Ledger 根路由传入 `onBack = { navController.smartBackToHome() }`
   - 在 Ledger 子路由（添加/编辑/筛选/详情）传入 `onNavigateBack = { navController.smartBackToLedger() }`

8) [（可选/按需）修改] 账户/预算/分类等带返回按钮的页面文件
   - 增加 `onNavigateBack` 并接线到 `NavGraph`

9) [（如需要）修改] `feature/ledger/api/LedgerApi.kt` 与 `LedgerApiImpl.kt`
   - 为 `getLedgerScreen` 增加 `onBack` 参数，并贯通到底层 `LedgerScreen`

## 开发步骤（建议顺序）
1) 新增 `NavigationExtensions.kt` 并通过 IDE 快速验证编译。
2) 修改 `LedgerScreen`：增加 `onBack` + `BackHandler`，本地编译验证。
3) 修改 `NavGraph.kt`：
   - `Screen.Ledger.route` 与 `LedgerWithAccountRoute.route` 处，向 `getLedgerScreen` 传入 `onBack`（若接口未扩展，则先扩展接口再改这里）。
4) 修改关键交易页面（Add/Edit/Filter/Detail）：增加 `onNavigateBack` 并将返回按钮接入。
5) 在 `NavGraph.kt` 为上述页面传入 `smartBackToLedger()`。
6) 逐步覆盖其它带返回按钮的 ledger 页面（账户、预算、分类等）。

## 回归测试用例
1) 从 App 首页进入记账首页：按系统返回键 → 回到 App 首页。
2) 从 App 首页进入记账首页 → 添加交易 → 返回按钮 → 回到记账首页。
3) 从外部 Deep Link 直达“添加交易” → 返回按钮 → 回到记账首页 → 再按返回 → 回到 App 首页 → 再按返回 → 退出应用。
4) 从外部 Deep Link 直达“记账首页” → 系统返回键 → 回到 App 首页。
5) 在记账首页打开抽屉 → 系统返回键 → 先关闭抽屉；再按返回 → 回到 App 首页。
6) 记账首页进入“搜索模式” → 系统返回键 → 退出搜索模式；再按返回 → 回到 App 首页。
7) 记账首页进入“选择模式” → 系统返回键 → 退出选择模式；再按返回 → 回到 App 首页。
8) 交易详情页 → 返回按钮 → 回到记账首页（若从详情页是从列表进入）。
9) 筛选页点击“取消/应用” → 回到记账首页（无论来源）。
10) 账户/预算/分类编辑页 → 返回按钮 → 回到记账首页。

## 验收标准
- 所有上述用例行为与预期一致；
- 无“卡死无法返回”与“直接退出应用”的异常；
- 返回链路清晰，不出现“误清栈导致历史丢失”的体验；
- 记账首页的抽屉/搜索/选择模式与系统返回键交互一致、自然。

## 风险与缓解
- 接口调整风险：`LedgerApi.getLedgerScreen` 增参需同步修改调用处；一次性完成接口对齐，并通过 IDE 全局查找校验。
- 依赖风险：若未引入 `BackHandler` 对应依赖，需补充 `androidx.activity:activity-compose`。
- 行为变更风险：避免“清栈式返回”，仅在明确需求处保留。

## 回滚方案
- 若引入问题，可仅保留 `NavigationExtensions.kt`，将页面 `onNavigateBack` 回退为旧实现（`navigateUp()`/`popBackStack()`），逐页回滚不影响数据库等状态。

## 附录：常用代码片段
```kotlin
// 1) 扩展：NavigationExtensions.kt（App 模块）
fun NavController.smartBack(fallbackRoute: String) { ... }
fun NavController.smartBackToHome() = smartBack(Screen.Home.route)
fun NavController.smartBackToLedger() = smartBack(Screen.Ledger.route)

// 2) Screen 端（Feature 模块）
IconButton(onClick = { onNavigateBack?.invoke() ?: navController.navigateUp() }) { ... }

// 3) LedgerScreen BackHandler（Feature 模块）
BackHandler {
    when { /* 抽屉/搜索/选择 优先处理 */ else -> onBack?.invoke() ?: navController?.popBackStack() }
}

// 4) NavGraph（App 模块）
ledgerApi.getLedgerScreen(navController, accountId = null, onBack = { navController.smartBackToHome() })
AddTransactionScreen(navController, transactionId, onNavigateBack = { navController.smartBackToLedger() })
```

