# Excel导入功能诊断计划

> 创建时间：2025-07-24  
> 目的：通过精确诊断找出导入功能完全失败的根本原因

## 一、诊断目标

通过添加详细的调试日志，确定导入功能在哪个具体环节失败，而不是基于猜测。

## 二、诊断代码

### 2.1 在ImportManagerAdapter中添加诊断方法

```kotlin
// 添加到 ImportManagerAdapter.kt
fun diagnoseImport(uri: Uri) {
    Log.e("DIAG", "========== 导入诊断开始 ==========")
    Log.e("DIAG", "时间: ${SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())}")
    Log.e("DIAG", "设备: ${Build.MANUFACTURER} ${Build.MODEL}")
    Log.e("DIAG", "Android版本: ${Build.VERSION.SDK_INT}")
    
    // 步骤1：检查URI
    Log.e("DIAG", "[步骤1] 检查URI")
    Log.e("DIAG", "URI: $uri")
    Log.e("DIAG", "URI Scheme: ${uri.scheme}")
    Log.e("DIAG", "URI Authority: ${uri.authority}")
    Log.e("DIAG", "URI Path: ${uri.path}")
    
    // 步骤2：检查文件信息
    Log.e("DIAG", "[步骤2] 检查文件信息")
    try {
        val cursor = context.contentResolver.query(uri, null, null, null, null)
        cursor?.use {
            if (it.moveToFirst()) {
                val displayName = it.getString(it.getColumnIndexOrThrow(OpenableColumns.DISPLAY_NAME))
                val size = it.getLong(it.getColumnIndexOrThrow(OpenableColumns.SIZE))
                Log.e("DIAG", "文件名: $displayName")
                Log.e("DIAG", "文件大小: $size bytes (${size/1024}KB)")
            }
        }
    } catch (e: Exception) {
        Log.e("DIAG", "获取文件信息失败", e)
    }
    
    // 步骤3：测试InputStream
    Log.e("DIAG", "[步骤3] 测试InputStream")
    try {
        val inputStream = context.contentResolver.openInputStream(uri)
        if (inputStream != null) {
            Log.e("DIAG", "✅ InputStream创建成功")
            
            // 读取前几个字节验证是否是有效文件
            val header = ByteArray(4)
            val bytesRead = inputStream.read(header)
            Log.e("DIAG", "读取字节数: $bytesRead")
            Log.e("DIAG", "文件头(hex): ${header.joinToString("") { "%02x".format(it) }}")
            
            inputStream.close()
            
            // 步骤4：测试FastExcel
            Log.e("DIAG", "[步骤4] 测试FastExcel解析")
            val newInputStream = context.contentResolver.openInputStream(uri)!!
            try {
                // 这里使用你项目中实际的FastExcel API
                val workbook = FastExcel.read(newInputStream)
                Log.e("DIAG", "✅ FastExcel创建Workbook成功")
                
                // 获取Sheet信息
                val sheets = workbook.sheets()
                Log.e("DIAG", "Sheet数量: ${sheets.size}")
                
                sheets.forEachIndexed { index, sheet ->
                    Log.e("DIAG", "Sheet[$index]: 名称='${sheet.name}'")
                    
                    // 尝试读取数据
                    try {
                        val rows = sheet.rows()
                        Log.e("DIAG", "Sheet[$index] 行数: ${rows.size}")
                        
                        if (rows.isNotEmpty()) {
                            val firstRow = rows[0]
                            Log.e("DIAG", "第一行列数: ${firstRow.cells().size}")
                            Log.e("DIAG", "第一行内容: ${firstRow.cells().map { it.value }}")
                        }
                    } catch (e: Exception) {
                        Log.e("DIAG", "读取Sheet[$index]数据失败", e)
                    }
                }
                
            } catch (e: Exception) {
                Log.e("DIAG", "❌ FastExcel解析失败", e)
                e.printStackTrace()
            } finally {
                newInputStream.close()
            }
            
        } else {
            Log.e("DIAG", "❌ InputStream为null")
        }
    } catch (e: Exception) {
        Log.e("DIAG", "❌ 创建InputStream失败", e)
        e.printStackTrace()
    }
    
    // 步骤5：检查数据库状态
    Log.e("DIAG", "[步骤5] 检查数据库状态")
    try {
        // 根据你的实际数据库查询
        val count = database.countdownDao().getAllCountdowns().size
        Log.e("DIAG", "当前数据库记录数: $count")
    } catch (e: Exception) {
        Log.e("DIAG", "查询数据库失败", e)
    }
    
    Log.e("DIAG", "========== 导入诊断结束 ==========")
}
```

### 2.2 在DataImportViewModel中调用诊断

```kotlin
// 临时修改 importFile 方法
fun importFile(uri: Uri) {
    viewModelScope.launch {
        // 先运行诊断
        importManagerAdapter.diagnoseImport(uri)
        
        // 然后执行原有的导入逻辑
        // ... 原有代码 ...
    }
}
```

## 三、执行步骤

1. **添加诊断代码**
   - 将上述代码添加到对应文件
   - 确保编译通过

2. **运行测试**
   - 选择一个简单的Excel文件（最好是之前成功导入过的）
   - 触发导入功能
   - 查看Logcat输出（过滤TAG: "DIAG"）

3. **收集日志**
   - 完整复制所有"DIAG"标签的日志
   - 特别注意任何❌标记和异常堆栈

## 四、预期结果分析

### 场景1：FastExcel无法处理InputStream
**日志特征**：
```
✅ InputStream创建成功
❌ FastExcel解析失败
java.io.FileNotFoundException: content://... (No such file or directory)
```
**原因**：FastExcel内部使用File API
**解决方案**：需要先将内容复制到临时文件

### 场景2：Sheet名称匹配问题
**日志特征**：
```
✅ FastExcel创建Workbook成功
Sheet数量: 3
Sheet[0]: 名称='Sheet1'
Sheet[1]: 名称='数据表'
```
**原因**：代码寻找特定名称的Sheet但没找到
**解决方案**：改进Sheet匹配逻辑

### 场景3：数据格式问题
**日志特征**：
```
✅ FastExcel创建Workbook成功
Sheet[0] 行数: 0
```
**原因**：Excel文件格式特殊或为空
**解决方案**：添加数据验证

### 场景4：权限问题
**日志特征**：
```
❌ 创建InputStream失败
java.lang.SecurityException: Permission Denial
```
**原因**：URI权限已失效
**解决方案**：实现权限持久化

## 五、根据诊断结果的修复方案

我们将根据实际的诊断日志，选择对应的修复方案：

### 方案A：如果是FastExcel不支持InputStream
```kotlin
// 创建临时文件方案
fun importFromUri(uri: Uri): Result<ImportResult> {
    val tempFile = File(context.cacheDir, "temp_import_${System.currentTimeMillis()}.xlsx")
    
    return try {
        // 复制到临时文件
        context.contentResolver.openInputStream(uri)?.use { input ->
            tempFile.outputStream().use { output ->
                input.copyTo(output)
            }
        }
        
        // 使用临时文件路径
        val workbook = FastExcel.read(tempFile)
        // ... 处理逻辑 ...
        
    } finally {
        tempFile.delete()
    }
}
```

### 方案B：如果是Sheet匹配问题
```kotlin
// 改进Sheet查找逻辑
fun findTargetSheet(workbook: Workbook): Sheet? {
    val sheets = workbook.sheets()
    
    // 优先精确匹配
    val exactMatch = sheets.find { 
        it.name in listOf("交易记录", "交易", "流水", "账单")
    }
    if (exactMatch != null) return exactMatch
    
    // 模糊匹配
    val fuzzyMatch = sheets.find {
        it.name.contains("交易") || it.name.contains("流水")
    }
    if (fuzzyMatch != null) return fuzzyMatch
    
    // 默认返回第一个Sheet
    return sheets.firstOrNull()
}
```

### 方案C：如果是数据读取问题
```kotlin
// 添加数据验证
fun validateAndParseSheet(sheet: Sheet): List<TransactionData> {
    val rows = sheet.rows()
    
    if (rows.isEmpty()) {
        throw ImportException("Excel文件为空")
    }
    
    // 跳过标题行
    return rows.drop(1).mapNotNull { row ->
        try {
            parseRow(row)
        } catch (e: Exception) {
            Log.w("Import", "跳过无效行: ${e.message}")
            null
        }
    }
}
```

## 六、执行计划

1. **立即执行**（30分钟）
   - 添加诊断代码
   - 运行测试
   - 收集日志

2. **分析诊断结果**（30分钟）
   - 确定具体失败点
   - 选择对应修复方案

3. **实施修复**（2-4小时）
   - 根据诊断结果实施具体方案
   - 添加必要的错误处理
   - 测试验证

4. **回归测试**（1小时）
   - 测试不同类型的Excel文件
   - 测试错误场景
   - 确保修复有效

## 七、成功标准

1. 诊断日志清晰显示失败原因
2. 修复后至少一个测试文件能成功导入
3. 有明确的错误提示而非静默失败

---

这个诊断计划的核心是：**先看到具体错误，再决定如何修复**。