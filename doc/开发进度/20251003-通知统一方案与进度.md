# 2025-10-03｜通知统一方案与进度计划（全项目通知能力）

本方案用于指导“通知能力”后续开发与验收，确保方向不跑偏。覆盖目标、范围、当前状态（已完成/进行中/待开发）、任务拆解与明确的验证方案（含通过/未通过标记），并附带风险与回滚建议。

— 本文档将随实现推进进行更新，同目录保留历史记录 —

## 1. 背景与目标
- 背景：项目内存在多类通知需求（任务、习惯、预算、信用卡、日程、自动记账交互）。需统一管道与风格，减少碎片化实现与权限/渠道问题。
- 目标：
  - 提供统一的“发送接口 + 渠道管理 + 调度（定时） + 监听（系统通知） + 诊断”能力。
  - 对外行为一致：用户能在“通知设置/自动记账设置”里启停并自检；渠道样式统一；易排障。
- 范围：
  - 发送与渠道：`shared/notification` 内的 `NotificationApi`、`NotificationManager`。
  - 调度（定时任务）：`app` 内的 `NotificationScheduler` 负责跨功能定时（任务/习惯/每日检查）。
  - 监听（系统通知）：`PaymentNotificationListener` + `NotificationEventRepository`（自动记账）。
  - 业务侧使用：Ledger（自动记账/信用卡提醒）、Schedule（日程提醒）、Profile（通知设置）。

## 2. 名词与模块
- NotificationApi：统一对外通知接口（发送/取消等）。
- NotificationManager（shared）：具体组装通知样式、渠道创建与 `NotificationManagerCompat.notify`。
- NotificationScheduler（app）：使用 WorkManager 安排任务/习惯/每日检查等定时工作。
- PaymentNotificationListener（shared）：系统通知监听服务（Android Notification Listener）。
- NotificationEventRepository：系统通知事件总线 + 监听健康诊断。
- AutoLedgerNotificationManager：自动记账的交互通知（半自动确认、撤销/编辑等）。
- Worker（HiltWorker）：通过 WorkManager 执行周期/一次性任务。

## 3. 当前状态总览

### 3.1 已完成（可用）
- 统一发送与渠道（已上线）
  - 接口/实现：`shared/notification/api/NotificationApi.kt`；`shared/notification/data/NotificationApiImpl.kt`
  - 样式/渠道：`shared/notification/data/manager/NotificationManager.kt`
  - 已包含渠道：任务/习惯/预算/信用卡/排班/通用。
- 自动记账监听与交互闭环（半自动优先，具备撤销/编辑，含诊断与一键重连）
  - 监听：`shared/notification/data/PaymentNotificationListener.kt`；清晰的关键词/群组摘要策略与 DataStore 开关。
  - 事件流：`shared/notification/data/NotificationEventRepositoryImpl.kt`（SharedFlow + 诊断统计）。
  - 使用权/渠道直达：`shared/notification/data/NotificationAccessControllerImpl.kt`。
  - 交互通知：`feature/ledger/domain/service/AutoLedgerNotificationManager.kt`（半自动确认渠道/撤销窗口）。
  - 生命周期接入：`app/CcXiaoJiApplication.kt`（按总开关启动/停止自动记账）、`feature/ledger` 设置页联通诊断与重连。
- 信用卡还款提醒（按 3/1/0 天提醒）
  - `feature/ledger/worker/creditcard/CreditCardReminderWorker.kt`（已注入 `NotificationApi` 并发送通知）。
- 日程（排班）每日提醒（固定时间提醒）
  - `feature/schedule/notification/ScheduleNotificationScheduler.kt` + `ScheduleNotificationWorker.kt`（直接使用 `NotificationManager` 发送“有/无排班”）。

### 3.2 进行中
- 每日检查框架已接入但逻辑待补（预算提醒落地前置）
  - `app/notification/NotificationScheduler.kt:daily_check` 已安排；
  - `app/notification/NotificationWorkers.kt:DailyCheckWorker` 标注 TODO（预算等检查缺失）。

### 3.3 待开发（本轮重点）
1) 任务提醒打通（从设置 → 安排 → 到点发送）
2) 习惯提醒打通（从设置 → 安排 → 到点发送）
3) 预算超支提醒落地（每日检查中计算预算占比，超过阈值时通知）
4) 通知设置页与后台调度联动（开关/时间变更即时生效，创建/取消相应 Work）
5) 日程提醒接入统一接口（将直接调用 `NotificationManager` 改为通过 `NotificationApi`，样式统一）
6) 将任务/习惯 Worker 改造为 `@HiltWorker` 并注入 `NotificationApi`

### 3.4 架构设计说明

#### 分层职责
- **shared/notification**（通用层）
  - 职责：发送通知、管理通知渠道、系统通知监听
  - 核心组件：`NotificationApi`、`NotificationManager`、`PaymentNotificationListener`
  - 说明：调度相关方法（scheduleTaskReminder等）抛出`UnsupportedOperationException`是预期设计，调度由app层负责

- **app/notification**（应用层）
  - 职责：使用WorkManager调度定时通知
  - 核心组件：`NotificationScheduler`（调度器）、`*ReminderWorker`（执行器）
  - 说明：依赖注入`NotificationApi`，调用shared层发送接口

- **业务模块**（feature/*）
  - 职责：调用`NotificationScheduler`传递业务数据
  - 示例：信用卡提醒（`CreditCardReminderManager`）、日程提醒（`ScheduleNotificationScheduler`）

#### 技术选型：WorkManager vs AlarmManager

**当前方案：WorkManager**

✅ **选择理由**：
1. 架构一致性 - 信用卡提醒、日程提醒已使用WorkManager
2. 系统级生命周期管理 - 自动处理开机自启、Doze模式、低电量场景
3. Hilt依赖注入友好 - `@HiltWorker`可直接注入Repository/Api
4. 降低复杂度 - 避免管理BroadcastReceiver、PendingIntent等底层API

⚠️ **技术限制**：
- 最小调度间隔：15分钟
- 触发精确度：±10分钟（系统批量调度优化）
- 适用场景："到期前30分钟提醒"、"每天固定时间段提醒"
- 不适合场景："准点8:00闹钟"（需要AlarmManager的`setExactAndAllowWhileIdle`）

🔮 **未来扩展**：
- 如用户反馈强烈要求精确提醒，可引入AlarmManager作为补充方案
- 参考权限管理页已声明的`SCHEDULE_EXACT_ALARM`权限（`app/src/main/java/com/ccxiaoji/app/presentation/ui/profile/PermissionManagementScreen.kt:75-80`）

#### 提醒策略：全局提醒 vs 单条提醒

**当前实现：全局提醒**
- 用户在"通知设置"统一开关，不区分单个任务/习惯
- 数据模型：`TaskEntity`/`HabitEntity`暂不包含`reminderAt`字段
- ViewModel联动策略：
  - 开关开启 → 从Repository查询所有符合条件的任务/习惯，批量安排提醒
  - 开关关闭 → 通过Tag取消所有对应类型的提醒

**可选扩展为单条提醒**：
- 扩展Entity字段（`reminderAt: Long?`、`reminderEnabled: Boolean`）
- UI支持单任务提醒设置
- 保存任务时同步安排/取消提醒

## 4. 任务执行计划（Task-based Implementation Plan）

本节定义所有开发任务的执行顺序、依赖关系和验收标准。所有Task按依赖关系执行，无依赖的Task可并行执行。

### 4.0 Task执行总览

#### 依赖关系图

```
Task-001 (TaskReminderWorker改造)      ─────┐
                                              ├─→ Task-003 (ViewModel依赖注入) ─┬─→ Task-004 (任务提醒联动) ─→ Task-006 (任务提醒E2E测试) ─┐
Task-002 (HabitReminderWorker改造)      ─────┘                                  │                                                              ├─→ Task-008 (预算超支提醒) ─→ Task-009 (日程提醒统一)
                                                                                 └─→ Task-005 (习惯提醒联动) ─→ Task-007 (习惯提醒E2E测试) ─┘
```

#### 并行执行机会
- **阶段1**：Task-001 ∥ Task-002（Worker改造可并行）
- **阶段2**：Task-004 ∥ Task-005（ViewModel联动逻辑可并行）
- **阶段3**：Task-006 ∥ Task-007（端到端测试可并行）

#### Task列表概览

| Task编号 | 任务名称 | 优先级 | 预估工作量 | 依赖 |
|---------|---------|--------|-----------|------|
| Task-001 | TaskReminderWorker改造为@HiltWorker | P0 | 30分钟 | 无 |
| Task-002 | HabitReminderWorker改造为@HiltWorker | P0 | 30分钟 | 无 |
| Task-003 | NotificationSettingsViewModel依赖注入 | P0 | 45分钟 | Task-001, Task-002 |
| Task-004 | 任务提醒开关联动逻辑 | P0 | 1.5小时 | Task-003 |
| Task-005 | 习惯提醒开关联动逻辑 | P0 | 1.5小时 | Task-003 |
| Task-006 | 端到端测试 - 任务提醒 | P0 | 2小时 | Task-004 |
| Task-007 | 端到端测试 - 习惯提醒 | P0 | 1天 | Task-005 |
| Task-008 | 预算超支提醒实现 | P0.5 | 3小时 | Task-006, Task-007 |
| Task-009 | 日程提醒统一到NotificationApi | P1 | 1小时 | Task-008 |

### 4.1 Task-001: TaskReminderWorker改造为@HiltWorker

**基本信息**
- 优先级: P0
- 依赖: 无
- 预估工作量: 30分钟
- 负责文件: `app/notification/NotificationWorkers.kt`

**实现要点**
1. 添加 `@HiltWorker` 注解到 `TaskReminderWorker` 类
2. 修改构造函数：
   ```kotlin
   @HiltWorker
   class TaskReminderWorker @AssistedInject constructor(
       @Assisted context: Context,
       @Assisted params: WorkerParameters,
       private val notificationApi: NotificationApi
   ) : Worker(context, params)
   ```
3. 解除注释，实际调用 `notificationApi.sendTaskReminder(taskId, taskTitle, dueTime)`
4. 添加异常处理，返回 `Result.success()` 或 `Result.failure()`
5. 添加日志输出（调用API前后打印）

**参考代码位置**
- 模板参考: `feature/ledger/worker/creditcard/CreditCardReminderWorker.kt:22-28`
- HiltWorkerFactory配置: `app/CcXiaoJiApplication.kt:192-194`

**验收标准**
- [ ] 代码编译通过，无Kotlin/Gradle错误
- [ ] `TaskReminderWorker` 类有 `@HiltWorker` 注解
- [ ] 构造函数注入了 `NotificationApi`
- [ ] `doWork()` 方法中调用了 `notificationApi.sendTaskReminder()`
- [ ] 添加了日志输出
- [ ] WorkManager可以成功创建该Worker实例

**验收方法**
```kotlin
// 在Application.onCreate中添加临时测试代码
val testRequest = OneTimeWorkRequestBuilder<TaskReminderWorker>()
    .setInputData(workDataOf(
        "task_id" to "test_task",
        "task_title" to "测试任务",
        "due_time" to "2025-10-05 10:00"
    ))
    .build()
WorkManager.getInstance(this).enqueue(testRequest)
// 观察日志：应输出 notificationApi.sendTaskReminder 被调用
```

**验收记录**
- 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____  | 备注：________________

---

### 4.2 Task-002: HabitReminderWorker改造为@HiltWorker

**基本信息**
- 优先级: P0
- 依赖: 无（可与Task-001并行）
- 预估工作量: 30分钟
- 负责文件: `app/notification/NotificationWorkers.kt`

**实现要点**
1. 添加 `@HiltWorker` 注解到 `HabitReminderWorker` 类
2. 修改构造函数：
   ```kotlin
   @HiltWorker
   class HabitReminderWorker @AssistedInject constructor(
       @Assisted context: Context,
       @Assisted params: WorkerParameters,
       private val notificationApi: NotificationApi
   ) : Worker(context, params)
   ```
3. 解除注释，实际调用 `notificationApi.sendHabitReminder(habitId, habitTitle)`
4. 添加异常处理和日志输出

**验收标准**
- [ ] 代码编译通过，无Kotlin/Gradle错误
- [ ] `HabitReminderWorker` 类有 `@HiltWorker` 注解
- [ ] 构造函数注入了 `NotificationApi`
- [ ] `doWork()` 方法中调用了 `notificationApi.sendHabitReminder()`
- [ ] 添加了日志输出
- [ ] WorkManager可以成功创建该Worker实例

**验收方法**
（类似Task-001，替换为HabitReminderWorker测试代码）

**验收记录**
- 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____  | 备注：________________

---

### 4.3 Task-003: NotificationSettingsViewModel依赖注入

**基本信息**
- 优先级: P0
- 依赖: Task-001, Task-002完成
- 预估工作量: 45分钟
- 负责文件: `app/presentation/viewmodel/NotificationSettingsViewModel.kt`

**实现要点**
1. 在构造函数中注入以下依赖：
   ```kotlin
   @HiltViewModel
   class NotificationSettingsViewModel @Inject constructor(
       private val dataStore: DataStore<Preferences>,
       private val notificationScheduler: NotificationScheduler,
       private val taskRepository: TaskRepository,
       private val habitRepository: HabitRepository,
       @ApplicationContext private val context: Context
   ) : ViewModel()
   ```
2. 确保 `@HiltViewModel` 注解已存在
3. 编译验证依赖注入正确

**参考代码位置**
- Repository注入参考: `app/presentation/viewmodel/ProfileViewModel.kt:17-19`

**验收标准**
- [ ] 代码编译通过，无Hilt依赖注入错误
- [ ] ViewModel构造函数包含4个新增依赖
- [ ] 在通知设置页面打开时，ViewModel能成功创建（无Crash）
- [ ] Logcat中无Hilt相关错误日志
- [ ] 可以在ViewModel方法中访问 `notificationScheduler` 和 `taskRepository`

**验收方法**
```kotlin
// 在NotificationSettingsViewModel.init{}中添加日志
init {
    Log.d("NotificationSettings", "ViewModel created successfully")
    Log.d("NotificationSettings", "NotificationScheduler: ${notificationScheduler.javaClass.simpleName}")
    Log.d("NotificationSettings", "TaskRepository: ${taskRepository.javaClass.simpleName}")
    Log.d("NotificationSettings", "HabitRepository: ${habitRepository.javaClass.simpleName}")
}
```

**验收记录**
- 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____  | 备注：________________

---

### 4.4 Task-004: 任务提醒开关联动逻辑

**基本信息**
- 优先级: P0
- 依赖: Task-003完成
- 预估工作量: 1.5小时
- 负责文件: `app/presentation/viewmodel/NotificationSettingsViewModel.kt`

**实现要点**
1. 修改 `setTaskDueReminder(enabled: Boolean)` 方法：
   ```kotlin
   fun setTaskDueReminder(enabled: Boolean) {
       viewModelScope.launch {
           dataStore.edit { preferences ->
               preferences[KEY_TASK_DUE_REMINDER] = enabled
           }

           if (enabled) {
               // 查询所有未完成且有截止时间的任务
               taskRepository.getAllTasks().first()
                   .filter { !it.completed && it.dueAt != null }
                   .forEach { task ->
                       val dueAt = Instant.fromEpochMilliseconds(task.dueAt!!)
                       notificationScheduler.scheduleTaskReminder(task.id, task.title, dueAt)
                   }
           } else {
               // 取消所有任务提醒
               WorkManager.getInstance(context)
                   .cancelAllWorkByTag(NotificationScheduler.TASK_REMINDER_WORK_TAG)
           }
       }
   }
   ```

2. 修改 `setTaskReminderMinutes(minutes: Int)` 方法：
   - 保存设置后，如果提醒已开启，重新调用 `setTaskDueReminder(true)`

**验收标准**
- [ ] 代码编译通过
- [ ] 在通知设置页面切换"任务到期提醒"开关：
  - [ ] 开启后，Logcat显示查询任务并调用 `scheduleTaskReminder`
  - [ ] 关闭后，Logcat显示 `cancelAllWorkByTag(TASK_REMINDER_WORK_TAG)`
- [ ] 通过WorkManager Inspector验证Work已创建/取消
- [ ] 修改"提前提醒时间"后，已有提醒会重新安排

**验收方法**
```bash
# 查看WorkManager中的Work
adb shell dumpsys activity service WorkManagerService

# 或使用Android Studio的 App Inspection → WorkManager
# 开启提醒后应看到多个 task_reminder_* 的Work
# 关闭提醒后这些Work应消失
```

**验收记录**
- 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____  | 备注：________________

---

### 4.5 Task-005: 习惯提醒开关联动逻辑

**基本信息**
- 优先级: P0
- 依赖: Task-003完成（可与Task-004并行）
- 预估工作量: 1.5小时
- 负责文件: `app/presentation/viewmodel/NotificationSettingsViewModel.kt`

**实现要点**
1. 修改 `setHabitReminder(enabled: Boolean)` 方法：
   ```kotlin
   fun setHabitReminder(enabled: Boolean) {
       viewModelScope.launch {
           dataStore.edit { preferences ->
               preferences[KEY_HABIT_REMINDER] = enabled
           }

           if (enabled) {
               val time = uiState.value.habitReminderTime.split(":")
               val hour = time[0].toInt()
               val minute = time[1].toInt()

               // 查询所有未删除的习惯
               habitRepository.getAllHabits().first()
                   .filter { !it.isDeleted }
                   .forEach { habit ->
                       notificationScheduler.scheduleDailyHabitReminder(
                           habit.id, habit.title, hour, minute
                       )
                   }
           } else {
               WorkManager.getInstance(context)
                   .cancelAllWorkByTag(NotificationScheduler.HABIT_REMINDER_WORK_TAG)
           }
       }
   }
   ```

2. 修改 `setHabitReminderTime(time: String)` 方法：
   - 时间变更后，如果提醒已开启，重新安排所有提醒

**验收标准**
- [ ] 代码编译通过
- [ ] 在通知设置页面切换"习惯打卡提醒"开关：
  - [ ] 开启后，Logcat显示查询习惯并调用 `scheduleDailyHabitReminder`
  - [ ] 关闭后，Logcat显示 `cancelAllWorkByTag(HABIT_REMINDER_WORK_TAG)`
- [ ] 通过WorkManager Inspector验证Work已创建/取消
- [ ] 修改"提醒时间"后，已有提醒会重新安排

**验收记录**
- 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____  | 备注：________________

---

### 4.6 Task-006: 端到端测试 - 任务提醒

**基本信息**
- 优先级: P0
- 依赖: Task-004完成
- 预估工作量: 2小时（包含等待时间）
- 测试范围: 完整的任务提醒流程

**测试步骤**
1. 创建一个测试任务，截止时间设置在未来35分钟
2. 在通知设置页面开启"任务到期提醒"
3. 等待30分钟后观察通知
4. 点击通知验证跳转逻辑
5. 关闭提醒，验证不再收到通知

**验收标准**
- [ ] 创建任务后，WorkManager中存在对应的 `task_reminder_[taskId]` Work
- [ ] Work的初始延迟约为5分钟（35分钟 - 30分钟提前提醒）
- [ ] 到期前30分钟（±10分钟误差范围内）收到通知
- [ ] 通知标题为"任务提醒"，内容包含任务标题和到期时间
- [ ] 点击通知能跳转到任务详情/待办列表页面
- [ ] 关闭"任务到期提醒"后，已创建的Work被取消

**验收记录表**

| 测试场景 | 预期结果 | 实际结果 | 通过/未通过 | 备注 |
|---------|---------|---------|-----------|------|
| 创建任务后Work存在 | ✅ | | □ 通过 / □ 未通过 | |
| 30分钟前收到通知 | ✅ | | □ 通过 / □ 未通过 | |
| 点击通知跳转正确 | ✅ | | □ 通过 / □ 未通过 | |
| 关闭开关Work取消 | ✅ | | □ 通过 / □ 未通过 | |

---

### 4.7 Task-007: 端到端测试 - 习惯提醒

**基本信息**
- 优先级: P0
- 依赖: Task-005完成（可与Task-006并行）
- 预估工作量: 1天（需跨天验证重复提醒）
- 测试范围: 完整的习惯提醒流程

**测试步骤**
1. 开启"习惯打卡提醒"，设置时间为当前时间+5分钟
2. 5分钟后观察是否收到通知
3. 点击通知验证跳转逻辑
4. 次日相同时间验证是否再次收到提醒
5. 修改提醒时间，验证次日按新时间触发
6. 关闭开关，验证不再收到提醒

**验收标准**
- [ ] 开启"习惯打卡提醒"后，WorkManager中存在 PeriodicWork
- [ ] 5分钟后（±10分钟误差）收到第一次提醒
- [ ] 通知标题为"习惯提醒"，内容包含习惯名称
- [ ] 点击通知能跳转到习惯打卡页面
- [ ] 次日相同时间再次收到提醒（验证PeriodicWork生效）
- [ ] 修改提醒时间后，次日按新时间触发
- [ ] 关闭开关后，不再收到提醒

**验收记录表**

| 测试场景 | 预期结果 | 实际结果 | 通过/未通过 | 备注 |
|---------|---------|---------|-----------|------|
| 首次提醒触发 | ✅ | | □ 通过 / □ 未通过 | |
| 点击通知跳转正确 | ✅ | | □ 通过 / □ 未通过 | |
| 次日重复提醒 | ✅ | | □ 通过 / □ 未通过 | |
| 修改时间后生效 | ✅ | | □ 通过 / □ 未通过 | |
| 关闭开关停止提醒 | ✅ | | □ 通过 / □ 未通过 | |

---

### 4.8 Task-008: 预算超支提醒实现

**基本信息**
- 优先级: P0.5
- 依赖: Task-006, Task-007完成
- 预估工作量: 3小时
- 负责文件: `app/notification/NotificationWorkers.kt` (DailyCheckWorker)

**实现要点**
1. 改造 `DailyCheckWorker` 为 `@HiltWorker`
2. 注入 `BudgetRepository`、`NotificationApi`、`DataStore<Preferences>`
3. 在 `doWork()` 中实现预算检查逻辑：
   ```kotlin
   @HiltWorker
   class DailyCheckWorker @AssistedInject constructor(
       @Assisted context: Context,
       @Assisted params: WorkerParameters,
       private val budgetRepository: BudgetRepository,
       private val notificationApi: NotificationApi,
       private val dataStore: DataStore<Preferences>
   ) : CoroutineWorker(context, params) {

       override suspend fun doWork(): Result {
           val threshold = dataStore.data.first()[KEY_BUDGET_ALERT_THRESHOLD] ?: 80
           val budgets = budgetRepository.getAllBudgets().first()

           budgets.forEach { budget ->
               val usagePercent = (budget.usedAmount * 100 / budget.totalAmount).toInt()
               if (usagePercent >= threshold) {
                   notificationApi.sendBudgetAlert(budget.categoryName, usagePercent)
               }
           }

           return Result.success()
       }
   }
   ```

**验收标准**
- [ ] 代码编译通过
- [ ] `DailyCheckWorker` 有 `@HiltWorker` 注解
- [ ] 创建一个预算，使用率为85%，阈值设置为80%
- [ ] 手动触发 `DailyCheckWorker`，收到"预算超支提醒"通知
- [ ] 通知显示分类名称和85%使用率
- [ ] 将阈值改为90%，再次触发，不应收到通知
- [ ] 使用率100%+时，通知文案显示"已超支"

**验收记录**
- 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____  | 备注：________________

---

### 4.9 Task-009: 日程提醒统一到NotificationApi

**基本信息**
- 优先级: P1
- 依赖: Task-008完成
- 预估工作量: 1小时
- 负责文件: `feature/schedule/notification/ScheduleNotificationWorker.kt`

**实现要点**
1. 找到 `ScheduleNotificationWorker` 中直接调用 `NotificationManager` 的代码
2. 替换为调用 `NotificationApi.sendGeneralNotification()`
3. 确保通知渠道与其他提醒保持一致

**验收标准**
- [ ] 代码编译通过
- [ ] `ScheduleNotificationWorker` 不再直接使用 `NotificationManager`
- [ ] 日程提醒通知的样式与任务/习惯提醒一致（同一渠道）
- [ ] 原有日程提醒功能不受影响（到点仍能收到通知）
- [ ] 通知点击跳转逻辑正常

**验收记录**
- 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____  | 备注：________________

## 5. 里程碑与排期建议
- P0（本周）：任务/习惯提醒打通 + 设置联动（1–2 天）
- P0.5（本周）：预算超支提醒（2–3 天）
- P1（下周）：统一日程提醒到 NotificationApi + Worker 注入改造（0.5–1 天）
- P2（回归）：多机型验证与问题收敛（1–2 天）

注：以上为功能性开发时间，不含外部依赖、复杂数据准备与大范围机型适配的不确定性缓冲。

## 6. 验证清单（按功能）
- 任务提醒
  - [ ] 设置开关与提前分钟变更后，能创建/更新/取消对应 Work
  - [ ] 到期前 30 分钟触发通知；点击进入正确页面
  - [ ] 关闭后不再触发
  - 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____

- 习惯提醒
  - [ ] 设置开关与时间变更后，能创建/更新/取消对应周期 Work
  - [ ] 到点触发通知；修改时间后按新时间次日触发
  - [ ] 关闭后不再触发
  - 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____

- 预算提醒（每日检查）
  - [ ] 阈值 80%/90%/100% 情况下通知策略正确
  - [ ] 设置阈值更新后，次日检查按新阈值执行
  - 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____

- 自动记账（回归）
  - [ ] 监听连接状态能显示；一键重连有效
  - [ ] 半自动：出现确认横幅，点击进入“记一笔”页
  - [ ] 撤销/编辑链路可用；撤销在 30s 窗口内有效
  - 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____

- 渠道/权限与一致性
  - [ ] 首次进入，若权限/渠道关闭，UI 有引导与直达
  - [ ] 不同 ROM 至少 2 台设备基本行为一致
  - 验证结果：□ 通过 / □ 未通过  | 验证人：____  | 日期：____

## 7. 风险与对策
- 系统权限/渠道差异（MIUI/HyperOS/原生）：提供"连接诊断/一键重连/直达渠道设置"；必要时在关键入口增加二次提示。
- WorkManager 的定时触发与厂商省电策略冲突：使用合适约束与较长窗口；重要提醒（如还款/任务）使用高优先级渠道；提供"立即测试"入口用于人工验证。
- 时间与时区：任务/习惯的时间换算统一到系统默认时区；注意"当日已过"的处理逻辑（次日触发）。
- 数据准备：预算计算依赖账本/分类数据完整性；提供最小可测数据集示例或内置样例。
- **WorkManager精确度限制**（新增）：
  - **风险描述**：
    - WorkManager的最小调度间隔为15分钟
    - 实际触发时间存在±10分钟误差（系统批量调度优化）
    - 可能导致"每天8:00提醒"实际在8:05-8:10触发
  - **影响范围**：
    - 习惯提醒（期望固定时间提醒，用户可能期待准点触发）
    - 任务提醒（到期前30分钟提醒，误差相对较小）
  - **缓解措施**：
    - UI标注"大约时间"，降低用户期望（如"约 20:00"）
    - 使用高优先级通知渠道（`Importance.HIGH`）提升触发优先级
    - 提供"立即测试"功能，验证提醒逻辑正确性（不验证精确度）
    - 在帮助文档说明："系统可能延迟最多10分钟，以优化电池使用"
  - **长期方案**：
    - 收集用户反馈，评估精确提醒需求强度
    - 如反馈强烈（如超过30%用户投诉时间不准），引入AlarmManager作为补充方案（需用户授权`SCHEDULE_EXACT_ALARM`权限）

## 8. 回滚策略
- 用户侧：关闭对应设置开关或通知使用权；
- 开发侧：
  - 暂停 `NotificationScheduler` 对应安排（取消 UniqueWork / Tag）；
  - 将 `DailyCheckWorker` 的预算检查包裹为可开关逻辑；
  - 自动记账保留半自动路径，故障时可一键停用。

## 9. 关联代码清单（定位用）
- 发送与渠道
  - `shared/notification/api/NotificationApi.kt`
  - `shared/notification/data/NotificationApiImpl.kt`
  - `shared/notification/data/manager/NotificationManager.kt`
- 调度与 Worker（app）
  - `app/src/main/java/com/ccxiaoji/app/notification/NotificationScheduler.kt`
  - `app/src/main/java/com/ccxiaoji/app/notification/NotificationWorkers.kt`
- 监听与诊断（shared）
  - `shared/notification/src/main/AndroidManifest.xml`
  - `shared/notification/data/PaymentNotificationListener.kt`
  - `shared/notification/data/NotificationEventRepositoryImpl.kt`
  - `shared/notification/data/NotificationAccessControllerImpl.kt`
- 业务侧接入
  - 自动记账交互：`feature/ledger/domain/service/AutoLedgerNotificationManager.kt`
  - 信用卡提醒：`feature/ledger/worker/creditcard/CreditCardReminderWorker.kt`
  - 日程提醒：`feature/schedule/notification/ScheduleNotificationScheduler.kt`、`ScheduleNotificationWorker.kt`
  - 设置页面：
    - 通知设置：`app/src/main/java/com/ccxiaoji/app/presentation/ui/profile/NotificationSettingsScreen.kt`
    - 通知设置 VM：`app/src/main/java/com/ccxiaoji/app/presentation/viewmodel/NotificationSettingsViewModel.kt`
    - 自动记账设置：`feature/ledger/presentation/screen/settings/AutoLedgerSettingsScreen.kt`

## 10. 变更记录
- 2025-10-03：首版方案文档，明确状态、拆解、验收与排期。
- 2025-10-04（第一次更新）：
  - 新增3.4节"架构设计说明"，明确分层职责与技术选型
  - 完善4.1/4.2节实现要点，新增分步骤指导与ViewModel联动逻辑
  - 补充第7节"WorkManager精确度限制"风险说明
  - 新增第11节"技术决策记录（ADR）"
- 2025-10-04（第二次更新 - Task化重构）：
  - **重大改动**：将第4节完全重构为Task-based执行计划
  - 新增4.0节"Task执行总览"，包含依赖关系图、并行执行机会、Task列表概览
  - 原4.1-4.6节重构为Task-001到Task-009共9个原子化任务
  - 删除原4.4节"设置联动与回归"（内容合并至Task-004和Task-005）
  - 删除原4.6节"Worker注入改造"（内容合并至Task-001和Task-002）
  - 每个Task新增：基本信息、实现要点、参考代码位置、验收标准、验收方法、验收记录
  - Task-006和Task-007新增验收记录表，便于跟踪测试结果
  - 预估总工作量：约12.5小时（不含等待时间）

## 11. 技术决策记录（ADR - Architecture Decision Record）

### ADR-001: 选择WorkManager作为通知调度方案

**决策时间**: 2025-10-03
**决策者**: 项目团队
**状态**: ✅ 已采纳

**背景**:
项目需要为任务、习惯、预算提供定时提醒功能。技术方案有两个选择：
1. AlarmManager（Android精确闹钟API）
2. WorkManager（Jetpack后台任务调度）

**决策**:
选择WorkManager作为主要调度方案。

**理由**:
1. **架构一致性** - 信用卡提醒（`CreditCardReminderWorker`）、日程提醒（`ScheduleNotificationWorker`）已使用WorkManager，保持技术栈统一
2. **生命周期管理** - WorkManager自动处理系统重启、Doze模式、低电量等复杂场景
3. **依赖注入友好** - `@HiltWorker`可直接注入Repository/Api，无需手动管理依赖（已配置`HiltWorkerFactory`）
4. **降低复杂度** - 避免管理PendingIntent、BroadcastReceiver注册、系统重启监听等底层API
5. **精确度够用** - "到期前30分钟提醒"场景下，±10分钟误差对用户体验影响有限

**权衡**:
- ❌ 精确度限制：最小间隔15分钟，±10分钟误差
- ❌ 不适合"准点闹钟"场景（如需精确8:00:00提醒）
- ✅ 适合"固定时间段提醒"场景（如8:00-8:10范围内提醒）

**后果**:
- 短期：快速完成P0任务（任务/习惯提醒），验证通知链路完整性
- 中期：收集用户反馈，评估精确度是否满足需求
- 长期：如用户反馈精确度不足，再引入AlarmManager作为补充方案（混合架构）

**相关代码**:
- `app/src/main/java/com/ccxiaoji/app/notification/NotificationScheduler.kt`
- `app/src/main/java/com/ccxiaoji/app/CcXiaoJiApplication.kt:192-194`（HiltWorkerFactory配置）
- `app/src/main/java/com/ccxiaoji/app/presentation/ui/profile/PermissionManagementScreen.kt:75-80`（精确闹钟权限已声明）
- `feature/ledger/worker/creditcard/CreditCardReminderWorker.kt`（参考实现）

**替代方案**:
- 方案B：直接使用AlarmManager
  - 优点：精确到秒级，适合严格时间要求的场景
  - 缺点：需要管理BroadcastReceiver、系统重启监听、Android 12+权限引导，复杂度高
  - 结论：暂不采纳，作为未来补充方案储备

