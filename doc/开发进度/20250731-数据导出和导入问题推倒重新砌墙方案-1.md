# 数据导出和导入功能重构方案 - FastExcel方案

## 🎯 项目背景

### 当前状况
- 经历了12个阶段的修复，仍然存在各种问题
- 代码复杂度高，维护困难
- CSV格式限制多，用户体验差
- 内存问题、性能问题频发

### 核心决策
**推倒重新砌墙** - 完全抛弃现有的CSV+ZIP方案，采用**CSV+JSON**组合方案实现全新的数据导入导出功能。

### 为什么选择CSV+JSON
1. **零依赖优势**：不需要第三方库，减少APK体积和依赖风险
2. **性能卓越**：CSV解析比Excel更快，JSON处理为Android原生支持
3. **用户体验好**：记账数据CSV格式可直接在Excel中查看，类似钱迹软件
4. **数据匹配度高**：大量表格数据用CSV，少量结构化数据用JSON
5. **技术实现简单**：原生API支持，开发维护成本更低
6. **文件体积更小**：比Excel格式文件更小，传输和存储更高效

## 📋 实施原则

### 1. 彻底重构原则
- **不修复，直接替换**：删除所有旧代码，从零开始
- **不兼容旧格式**：项目未发布，无需考虑向后兼容
- **简单优先**：选择最简单直接的实现方式

### 2. 技术选型原则
- **混合文件格式**：记账数据使用CSV格式，其他数据使用JSON格式
- **流式处理**：大量数据（CSV）使用流式API，结构化数据（JSON）使用标准解析
- **模块化设计**：每个业务模块独立的导入导出逻辑

### 3. 用户体验原则
- **直观可视**：记账CSV文件可直接在Excel中查看，类似钱迹软件体验
- **结构清晰**：大量数据用CSV表格，少量数据用JSON结构化存储
- **进度反馈**：实时显示导入导出进度

## 🏗️ 技术架构

### 1. 整体架构
```
app/src/main/kotlin/com/ccxiaoji/app/data/backup/
├── BackupManager.kt              # 总控制器
├── CsvExporter.kt               # CSV导出接口和实现
├── CsvImporter.kt               # CSV导入接口和实现
├── JsonExporter.kt              # JSON导出接口和实现
├── JsonImporter.kt              # JSON导入接口和实现
├── BackupMetadata.kt            # 元数据模型
├── BackupValidator.kt           # 数据验证器
├── mappers/                     # 数据映射器
│   ├── TransactionCsvMapper.kt  # 交易记录CSV映射
│   ├── LedgerJsonMapper.kt      # 记账主数据JSON映射
│   ├── TodoJsonMapper.kt        # 待办JSON映射
│   ├── HabitJsonMapper.kt       # 习惯JSON映射
│   └── ...
└── models/                      # 备份数据模型
    ├── BackupConfig.kt
    ├── BackupResult.kt
    └── BackupError.kt
```

### 2. 核心组件设计

#### BackupManager（总控制器）
```kotlin
@Singleton
class BackupManager @Inject constructor(
    private val csvExporter: CsvExporter,
    private val csvImporter: CsvImporter,
    private val jsonExporter: JsonExporter,
    private val jsonImporter: JsonImporter,
    private val validator: BackupValidator
) {
    suspend fun exportBackup(
        uri: Uri,
        config: BackupConfig,
        progressCallback: (Float, String) -> Unit
    ): Result<BackupStats>
    
    suspend fun importBackup(
        uri: Uri,
        mode: ImportMode,
        progressCallback: (Float, String) -> Unit
    ): Result<BackupStats>
}
```

#### CsvExporter（CSV导出器）
```kotlin
interface CsvExporter {
    suspend fun exportTransactions(
        outputStream: OutputStream,
        config: BackupConfig,
        onProgress: (Float, String) -> Unit
    ): CsvExportStats
}

class TransactionCsvExporter @Inject constructor(
    private val transactionMapper: TransactionCsvMapper
) : CsvExporter {
    override suspend fun exportTransactions(...): CsvExportStats {
        // 1. 写入CSV头部
        writer.writeHeader("ID", "时间", "类型", "金额", "账户", "分类", "备注")
        
        // 2. 流式写入交易数据
        transactionRepository.getAllTransactionsFlow().collect { transaction ->
            writer.writeRecord(
                transaction.id,
                transaction.formatDateTime(),
                transaction.type,
                transaction.formatAmount(),
                transaction.accountName,
                transaction.categoryName,
                transaction.note ?: ""
            )
        }
    }
}
```

#### JsonExporter（JSON导出器）
```kotlin
interface JsonExporter {
    suspend fun exportModule(
        moduleType: ModuleType,
        config: BackupConfig
    ): JsonObject
}

class ModuleJsonExporter @Inject constructor(
    private val mappers: Map<ModuleType, JsonMapper>
) : JsonExporter {
    override suspend fun exportModule(moduleType: ModuleType, config: BackupConfig): JsonObject {
        val mapper = mappers[moduleType] ?: throw IllegalArgumentException("Unknown module: $moduleType")
        return mapper.exportToJson(config)
    }
}
```

### 3. 数据模型设计

#### 备份文件结构
```
CC小记备份_2025-07-31.zip
├── metadata.json                    # 备份元数据
│   ├── 版本信息
│   ├── 导出时间
│   ├── 应用版本
│   └── 数据统计
├── transactions.csv                 # 交易记录（大量数据）
│   ├── 交易记录
│   └── 参考钱迹格式，用户友好
├── ledger_master.json              # 记账主数据
│   ├── 账户信息
│   ├── 分类信息
│   ├── 预算信息
│   └── 信用卡等其他记账数据
├── todo.json                        # 待办数据
│   └── 任务列表
├── habit.json                       # 习惯数据
│   ├── 习惯定义
│   └── 打卡记录
├── schedule.json                    # 排班数据
│   ├── 班次定义
│   ├── 排班记录
│   └── 排班模式
├── plan.json                        # 计划数据（支持树形结构）
│   ├── 计划列表
│   ├── 里程碑
│   └── 模板
└── others.json                      # 其他数据
    ├── 倒计时
    ├── 用户设置
    └── 变更日志
```

#### 元数据文件设计（metadata.json）
```json
{
  "fileType": "CC小记备份文件",
  "fileVersion": "2.0",
  "exportTime": "2025-07-31T10:30:00Z",
  "appVersion": "2.5.0",
  "deviceInfo": "Android 14",
  "dataRange": {
    "startDate": "2024-01-01",
    "endDate": "2025-07-31"
  },
  "statistics": {
    "transactionCount": 1234,
    "todoCount": 56,
    "habitRecordCount": 789,
    "scheduleCount": 150,
    "planCount": 25
  },
  "files": {
    "transactions.csv": "交易记录数据",
    "ledger_master.json": "记账主数据",
    "todo.json": "待办数据",
    "habit.json": "习惯数据",
    "schedule.json": "排班数据", 
    "plan.json": "计划数据",
    "others.json": "其他数据"
  },
  "checksum": {
    "algorithm": "SHA-256",
    "value": "abc123..."
  }
}
```

#### 交易记录CSV格式（钱迹兼容）
```csv
"ID","时间","分类","二级分类","类型","金额","币种","账户1","账户2","备注","已报销","手续费","优惠券","记账者","账单标记","标签","账单图片","关联账单"
"cc_1722412200000","2025-07-31 10:30:00","餐饮","","支出","25.50","CNY","微信零钱","","午餐","","","","CC小记用户","","","",""
```

#### 字段映射策略说明

| 钱迹字段 | CC小记字段 | 映射规则 | 示例值 |
|---------|-----------|---------|--------|
| ID | TransactionEntity.id | `cc_${createdAt}` | `cc_1722412200000` |
| 时间 | TransactionEntity.date | 直接映射 | `2025-07-31 10:30:00` |
| 分类 | CategoryEntity.name | 通过categoryId关联 | `餐饮` |
| 二级分类 | - | 固定空值 | `""` |
| 类型 | TransactionEntity.type | 枚举转字符串 | `支出`/`收入` |
| 金额 | TransactionEntity.amount | 分转元处理 | `25.50` |
| 币种 | - | 固定CNY | `CNY` |
| 账户1 | AccountEntity.name | 通过accountId关联 | `微信零钱` |
| 账户2 | - | 转账场景使用 | `""` |
| 备注 | TransactionEntity.note | 直接映射，空值处理 | `午餐` |
| 已报销 | - | 企业版功能预留 | `""` |
| 手续费 | - | 金融扩展预留 | `""` |
| 优惠券 | - | 营销功能预留 | `""` |
| 记账者 | UserEntity.name | 默认或实际用户名 | `CC小记用户` |
| 账单标记 | - | 标签扩展预留 | `""` |
| 标签 | TransactionEntity.tags | 逗号分隔 | `标签1,标签2` |
| 账单图片 | - | 图片功能预留 | `""` |
| 关联账单 | - | 关联场景预留 | `原交易ID` |

### 4. 数据库真实结构（基于代码分析）

#### 数据库版本：7

#### 完整实体列表（23个表）
```
1. 用户模块 (1表)
   - UserEntity

2. 记账模块 (9表)
   - TransactionEntity      - 交易记录
   - AccountEntity          - 账户（含信用卡扩展字段）
   - CategoryEntity         - 分类
   - BudgetEntity          - 预算
   - RecurringTransactionEntity - 定期交易
   - SavingsGoalEntity     - 储蓄目标
   - SavingsContributionEntity - 储蓄贡献
   - CreditCardBillEntity  - 信用卡账单
   - CreditCardPaymentEntity - 信用卡还款

3. 待办模块 (1表)
   - TaskEntity            - 任务

4. 习惯模块 (2表)
   - HabitEntity           - 习惯定义
   - HabitRecordEntity     - 打卡记录

5. 排班模块 (4表)
   - ShiftEntity           - 班次定义
   - ScheduleEntity        - 排班记录
   - PatternEntity         - 排班模式
   - ExportHistoryEntity   - 导出历史

6. 计划模块 (3表)
   - PlanEntity            - 计划（树形结构）
   - MilestoneEntity       - 里程碑
   - TemplateEntity        - 计划模板

7. 其他数据 (2表)
   - CountdownEntity       - 倒计时
   - ChangeLogEntity       - 变更日志
```

#### 导入顺序依赖
```
第1层（独立表）：
- UserEntity
- CategoryEntity
- ShiftEntity
- TemplateEntity
- PatternEntity

第2层（依赖User）：
- AccountEntity
- TaskEntity
- HabitEntity
- PlanEntity (可自引用)
- CountdownEntity

第3层（依赖第2层）：
- TransactionEntity (依赖Account, Category)
- BudgetEntity (依赖Category)
- RecurringTransactionEntity (依赖Account, Category)
- SavingsGoalEntity
- SavingsContributionEntity (依赖SavingsGoal)
- CreditCardBillEntity (依赖Account)
- CreditCardPaymentEntity (依赖Account, Bill)
- HabitRecordEntity (依赖Habit)
- ScheduleEntity (依赖Shift)
- MilestoneEntity (依赖Plan)
- ExportHistoryEntity

第4层（变更记录）：
- ChangeLogEntity
```

### 5. 基于真实数据结构的数据组织方案

#### 5.1 Excel工作表结构设计
根据23个表的实际情况，调整Excel文件结构：
```
CC小记备份.xlsx
├── 元数据 (Metadata)
├── 记账数据 (Ledger) - 包含9个表的数据
├── 待办任务 (Todo) - 包含1个表的数据  
├── 习惯记录 (Habit) - 包含2个表的数据
├── 排班数据 (Schedule) - 包含4个表的数据
├── 计划数据 (Plan) - 包含3个表的数据
└── 其他数据 (Others) - 包含User、Countdown、ChangeLog
```

#### 5.2 各工作表数据组织

**记账数据表组织**（9个表在一个Sheet中按区块排列）：
```
=== 账户信息 ===
[AccountEntity数据]

=== 分类信息 ===
[CategoryEntity数据]

=== 交易记录 ===
[TransactionEntity数据]

=== 预算设置 ===
[BudgetEntity数据]

=== 定期交易 ===
[RecurringTransactionEntity数据]

=== 储蓄目标 ===
[SavingsGoalEntity数据]
[SavingsContributionEntity数据]

=== 信用卡管理 ===
[CreditCardBillEntity数据]
[CreditCardPaymentEntity数据]
```

**其他模块组织**：
- Todo：单表直接导出
- Habit：HabitEntity和HabitRecordEntity分区块
- Schedule：4个表分区块（注意snake_case转换）
- Plan：3个表分区块（注意树形结构的parentId）
- Others：User、Countdown、ChangeLog分区块

#### 5.3 数据字段处理规则

1. **命名规范统一**：
   - Schedule模块的snake_case（如`shift_id`、`created_at`）导出时转为camelCase
   - 导入时根据目标表结构自动转换回snake_case

2. **特殊字段处理**：
   - JSON字段（PlanEntity的tags、reminderSettings）保持JSON字符串格式
   - 时间戳转换为可读日期格式：`2025-07-31 10:30:00`
   - 金额字段从分转换为元：`amountCents / 100`
   - Boolean字段转换为是/否

3. **钱迹兼容字段处理**：
   - **ID格式**：使用`cc_[timestamp]`格式替代简单编号
   - **二级分类**：暂时为空字符串`""`，为未来扩展保留
   - **币种**：默认填入`"CNY"`，支持多币种时可扩展
   - **账户1/账户2**：普通交易填账户1，转账时使用双账户
   - **已报销**：暂时为空`""`，企业版功能预留
   - **手续费**：暂时为空`""`，金融账户扩展时使用
   - **优惠券**：暂时为空`""`，营销功能预留
   - **记账者**：默认填入`"CC小记用户"`或实际用户名
   - **账单标记**：暂时为空`""`，标签扩展功能
   - **标签**：多个标签用逗号分隔，如`"标签1,标签2"`
   - **账单图片**：暂时为空`""`，未来支持图片附件
   - **关联账单**：用于退款等关联场景，填入原交易ID

4. **状态字段处理**：
   - syncStatus：导出时保留，导入时可选重置
   - isDeleted：提供选项是否导出已删除数据

#### 5.4 导入顺序控制

在元数据表中明确记录导入顺序：
```
导入顺序 | 表名 | 所在Sheet | 依赖表
-------|------|----------|--------
1 | UserEntity | 其他数据 | 无
1 | CategoryEntity | 记账数据 | 无  
1 | ShiftEntity | 排班数据 | 无
1 | TemplateEntity | 计划数据 | 无
1 | PatternEntity | 排班数据 | 无
2 | AccountEntity | 记账数据 | UserEntity
2 | TaskEntity | 待办任务 | UserEntity
2 | HabitEntity | 习惯记录 | UserEntity
2 | PlanEntity | 计划数据 | UserEntity, TemplateEntity
2 | CountdownEntity | 其他数据 | UserEntity
3 | TransactionEntity | 记账数据 | AccountEntity, CategoryEntity
3 | BudgetEntity | 记账数据 | CategoryEntity
... (完整列表)
```

#### 5.5 外键引用处理策略

1. **导出时**：
   - 保留原始ID和所有外键值
   - 不做任何ID转换，保持数据原始性

2. **导入时**：
   - 提供两种模式：保留原ID / 重新生成ID
   - 如果重新生成ID，建立映射表并更新所有外键引用

### 6. 模块映射器设计

每个业务模块都有专门的映射器负责数据转换：

```kotlin
interface ExcelMapper {
    val moduleType: ModuleType
    val sheetName: String
    
    suspend fun exportToSheet(
        workbook: Workbook,
        onProgress: (Float, String) -> Unit
    ): Int // 返回导出的记录数
    
    suspend fun importFromSheet(
        sheet: Sheet,
        mode: ImportMode,
        onProgress: (Float, String) -> Unit
    ): Int // 返回导入的记录数
}

// 示例：记账模块映射器
class LedgerExcelMapper @Inject constructor(
    private val transactionRepo: TransactionRepository,
    private val accountRepo: AccountRepository,
    private val categoryRepo: CategoryRepository
) : ExcelMapper {
    override val moduleType = ModuleType.LEDGER
    override val sheetName = "记账数据"
    
    override suspend fun exportToSheet(workbook: Workbook, onProgress: (Float, String) -> Unit): Int {
        val sheet = workbook.newWorksheet(sheetName)
        var row = 0
        
        // 导出交易记录
        sheet.value(row, 0, "=== 交易记录 ===")
        row = exportTransactions(sheet, row + 2, onProgress)
        
        // 导出账户信息
        sheet.value(row + 1, 0, "=== 账户信息 ===")
        row = exportAccounts(sheet, row + 3, onProgress)
        
        // 导出分类信息
        sheet.value(row + 1, 0, "=== 分类信息 ===")
        row = exportCategories(sheet, row + 3, onProgress)
        
        return row
    }
    
    private suspend fun exportTransactions(sheet: Worksheet, startRow: Int, onProgress: (Float, String) -> Unit): Int {
        // 写入表头（钱迹兼容格式）
        val headers = listOf("ID", "时间", "分类", "二级分类", "类型", "金额", "币种", "账户1", "账户2", "备注", "已报销", "手续费", "优惠券", "记账者", "账单标记", "标签", "账单图片", "关联账单")
        headers.forEachIndexed { col, header ->
            sheet.style(startRow, col).bold().set()
            sheet.value(startRow, col, header)
        }
        
        // 流式写入数据（钱迹兼容格式）
        var row = startRow + 1
        var count = 0
        transactionRepo.getAllTransactionsFlow().collect { transaction ->
            sheet.value(row, 0, "cc_${transaction.createdAt}")  // ID：cc_时间戳格式
            sheet.value(row, 1, transaction.date.toString())    // 时间
            sheet.value(row, 2, transaction.categoryName)       // 分类
            sheet.value(row, 3, "")                            // 二级分类：暂时为空
            sheet.value(row, 4, transaction.type.name)         // 类型
            sheet.value(row, 5, transaction.amount)            // 金额
            sheet.value(row, 6, "CNY")                         // 币种
            sheet.value(row, 7, transaction.accountName)       // 账户1
            sheet.value(row, 8, "")                            // 账户2：转账时使用
            sheet.value(row, 9, transaction.note ?: "")        // 备注
            sheet.value(row, 10, "")                           // 已报销：企业版功能
            sheet.value(row, 11, "")                           // 手续费
            sheet.value(row, 12, "")                           // 优惠券
            sheet.value(row, 13, "CC小记用户")                   // 记账者
            sheet.value(row, 14, "")                           // 账单标记
            sheet.value(row, 15, transaction.tags.joinToString(","))  // 标签
            sheet.value(row, 16, "")                           // 账单图片
            sheet.value(row, 17, "")                           // 关联账单
            
            row++
            count++
            
            if (count % 100 == 0) {
                onProgress(count / estimatedTotal, "正在导出交易记录：$count 条")
            }
        }
        
        return row
    }
}
```

## 🏗️ 砌墙计划（Phase 2-6: 22小时）

### Phase 2: 搭建基础框架（3小时）

#### 2.1 创建全新的包结构
```
app/src/main/kotlin/com/ccxiaoji/app/data/backup/
├── manager/
│   └── BackupManager.kt          # 统一入口
├── export/
│   ├── CsvExporter.kt           # CSV导出器
│   ├── JsonExporter.kt          # JSON导出器
│   └── ZipPackager.kt           # ZIP打包器
├── import/
│   ├── CsvImporter.kt           # CSV导入器
│   ├── JsonImporter.kt          # JSON导入器
│   └── ZipExtractor.kt          # ZIP解压器
├── mapper/
│   ├── TransactionMapper.kt     # 交易记录映射
│   ├── LedgerMapper.kt          # 记账数据映射
│   ├── TodoMapper.kt            # 待办映射
│   ├── HabitMapper.kt           # 习惯映射
│   ├── ScheduleMapper.kt        # 排班映射
│   ├── PlanMapper.kt            # 计划映射
│   └── OthersMapper.kt          # 其他数据映射
└── model/
    ├── BackupMetadata.kt        # 元数据模型
    ├── BackupResult.kt          # 结果模型
    └── BackupError.kt           # 错误模型
```

#### 2.2 定义核心接口
```kotlin
// BackupManager - 统一入口
@Singleton
class BackupManager @Inject constructor(
    private val csvExporter: CsvExporter,
    private val jsonExporter: JsonExporter,
    private val csvImporter: CsvImporter,
    private val jsonImporter: JsonImporter,
    private val zipPackager: ZipPackager,
    private val zipExtractor: ZipExtractor
) {
    suspend fun export(
        uri: Uri,
        config: ExportConfig,
        onProgress: (Float, String) -> Unit
    ): Result<BackupStats>
    
    suspend fun import(
        uri: Uri,
        mode: ImportMode,
        onProgress: (Float, String) -> Unit
    ): Result<ImportStats>
}
```

#### 2.3 配置Hilt依赖注入
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object BackupModule {
    @Provides
    @Singleton
    fun provideBackupManager(
        csvExporter: CsvExporter,
        jsonExporter: JsonExporter,
        // ... 其他依赖
    ): BackupManager = BackupManager(/* ... */)
}
```

### Phase 3: 实现核心功能（8小时）

#### 3.1 BackupMetadata实现（1小时）
```kotlin
@Serializable
data class BackupMetadata(
    val fileType: String = "CC小记备份文件",
    val fileVersion: String = "2.0",
    val exportTime: String,
    val appVersion: String,
    val deviceInfo: String,
    val dataRange: DataRange,
    val statistics: Statistics,
    val files: Map<String, String>,
    val checksum: Checksum
) {
    @Serializable
    data class Statistics(
        val transactionCount: Int,
        val todoCount: Int,
        val habitRecordCount: Int,
        val scheduleCount: Int,
        val planCount: Int
    )
}
```

#### 3.2 CsvExporter实现（2小时）
```kotlin
class CsvExporter @Inject constructor(
    private val transactionMapper: TransactionMapper
) {
    /**
     * 导出交易记录为钱迹兼容格式
     */
    suspend fun exportTransactions(
        outputStream: OutputStream,
        transactions: Flow<TransactionEntity>,
        onProgress: (Int, Int) -> Unit
    ) {
        val writer = outputStream.bufferedWriter()
        
        // 写入钱迹兼容的CSV头部
        writer.appendLine(QIANJI_CSV_HEADER)
        
        var count = 0
        transactions.collect { transaction ->
            val csvLine = transactionMapper.toCsvLine(transaction)
            writer.appendLine(csvLine)
            count++
            if (count % 100 == 0) {
                onProgress(count, -1) // -1表示总数未知
            }
        }
        
        writer.flush()
    }
    
    companion object {
        private const val QIANJI_CSV_HEADER = 
            "ID,时间,分类,二级分类,类型,金额,币种,账户1,账户2,备注," +
            "已报销,手续费,优惠券,记账者,账单标记,标签,账单图片,关联账单"
    }
}
```

#### 3.3 JsonExporter实现（2小时）
```kotlin
class JsonExporter @Inject constructor(
    private val json: Json,
    private val ledgerMapper: LedgerMapper,
    private val todoMapper: TodoMapper,
    // ... 其他mapper
) {
    /**
     * 导出记账主数据
     */
    suspend fun exportLedgerMaster(
        accounts: List<AccountEntity>,
        categories: List<CategoryEntity>,
        budgets: List<BudgetEntity>,
        // ... 其他数据
    ): JsonElement {
        val ledgerData = LedgerMasterData(
            accounts = accounts.map { ledgerMapper.toExportModel(it) },
            categories = categories.map { ledgerMapper.toExportModel(it) },
            budgets = budgets.map { ledgerMapper.toExportModel(it) }
        )
        return json.encodeToJsonElement(ledgerData)
    }
    
    /**
     * 导出其他模块数据
     */
    suspend fun exportModule(
        moduleType: ModuleType,
        data: Any
    ): JsonElement {
        return when (moduleType) {
            ModuleType.TODO -> exportTodoData(data as TodoData)
            ModuleType.HABIT -> exportHabitData(data as HabitData)
            ModuleType.SCHEDULE -> exportScheduleData(data as ScheduleData)
            ModuleType.PLAN -> exportPlanData(data as PlanData)
            ModuleType.OTHERS -> exportOthersData(data as OthersData)
        }
    }
}
```

#### 3.4 导入器实现（3小时）
```kotlin
class CsvImporter @Inject constructor(
    private val transactionMapper: TransactionMapper
) {
    /**
     * 从CSV导入交易记录
     */
    suspend fun importTransactions(
        inputStream: InputStream,
        onProgress: (Int) -> Unit
    ): Flow<TransactionImportModel> = flow {
        val reader = inputStream.bufferedReader()
        val headers = reader.readLine()?.split(",") ?: return@flow
        
        var line: String?
        var count = 0
        while (reader.readLine().also { line = it } != null) {
            line?.let {
                val values = parseCsvLine(it)
                val model = transactionMapper.fromCsvLine(headers, values)
                emit(model)
                count++
                if (count % 100 == 0) {
                    onProgress(count)
                }
            }
        }
    }
}
```

### Phase 4: 模块映射器实现（6小时）

#### 4.1 TransactionMapper（钱迹兼容）（2小时）
```kotlin
class TransactionMapper @Inject constructor(
    private val accountDao: AccountDao,
    private val categoryDao: CategoryDao
) {
    /**
     * 实体转CSV行（钱迹格式）
     */
    suspend fun toCsvLine(entity: TransactionEntity): String {
        val account = accountDao.getById(entity.accountId)
        val category = categoryDao.getById(entity.categoryId)
        
        return listOf(
            "cc_${entity.createdAt}",              // ID
            formatDateTime(entity.date),           // 时间
            category?.name ?: "",                  // 分类
            "",                                    // 二级分类（暂未支持）
            if (entity.type == TransactionType.EXPENSE) "支出" else "收入",
            formatAmount(entity.amount),           // 金额
            "CNY",                                 // 币种
            account?.name ?: "",                   // 账户1
            "",                                    // 账户2（转账时使用）
            entity.note ?: "",                     // 备注
            "",                                    // 已报销
            "",                                    // 手续费
            "",                                    // 优惠券
            "CC小记用户",                          // 记账者
            "",                                    // 账单标记
            entity.tags.joinToString(","),         // 标签
            "",                                    // 账单图片
            ""                                     // 关联账单
        ).joinToString(",") { escapeCSV(it) }
    }
    
    /**
     * CSV行转导入模型
     */
    fun fromCsvLine(headers: List<String>, values: List<String>): TransactionImportModel {
        val valueMap = headers.zip(values).toMap()
        
        return TransactionImportModel(
            originalId = valueMap["ID"] ?: "",
            date = parseDateTime(valueMap["时间"] ?: ""),
            categoryName = valueMap["分类"] ?: "",
            type = if (valueMap["类型"] == "支出") TransactionType.EXPENSE else TransactionType.INCOME,
            amount = parseAmount(valueMap["金额"] ?: "0"),
            accountName = valueMap["账户1"] ?: "",
            note = valueMap["备注"],
            tags = valueMap["标签"]?.split(",")?.filter { it.isNotBlank() } ?: emptyList()
        )
    }
}
```

#### 4.2 其他模块映射器（4小时）
```kotlin
// LedgerMapper - 记账主数据映射
class LedgerMapper @Inject constructor() {
    fun toExportModel(entity: AccountEntity): AccountExportModel {
        return AccountExportModel(
            id = entity.id,
            name = entity.name,
            type = entity.type,
            balance = entity.balance,
            // ... 其他字段
        )
    }
}

// TodoMapper - 待办任务映射
class TodoMapper @Inject constructor() {
    fun toExportModel(entity: TaskEntity): TaskExportModel {
        return TaskExportModel(
            id = entity.id,
            content = entity.content,
            isCompleted = entity.isCompleted,
            // ... 其他字段
        )
    }
}

// ScheduleMapper - 处理snake_case转换
class ScheduleMapper @Inject constructor() {
    fun toExportModel(entity: ScheduleEntity): ScheduleExportModel {
        return ScheduleExportModel(
            shiftId = entity.shift_id,        // snake_case → camelCase
            scheduleDate = entity.schedule_date,
            createdAt = entity.created_at,
            // ... 其他字段
        )
    }
}
```

### Phase 5: UI层实现（4小时）

#### 5.1 新的ViewModel实现（2小时）
```kotlin
@HiltViewModel
class BackupExportViewModel @Inject constructor(
    private val backupManager: BackupManager
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ExportUiState())
    val uiState: StateFlow<ExportUiState> = _uiState.asStateFlow()
    
    fun exportData(uri: Uri) {
        viewModelScope.launch {
            _uiState.update { it.copy(isExporting = true, progress = 0f) }
            
            backupManager.export(
                uri = uri,
                config = ExportConfig(
                    modules = _uiState.value.selectedModules,
                    dateRange = _uiState.value.dateRange
                ),
                onProgress = { progress, message ->
                    _uiState.update { 
                        it.copy(
                            progress = progress,
                            progressMessage = message
                        )
                    }
                }
            ).fold(
                onSuccess = { stats ->
                    _uiState.update { 
                        it.copy(
                            isExporting = false,
                            exportResult = ExportResult.Success(stats)
                        )
                    }
                },
                onFailure = { error ->
                    _uiState.update { 
                        it.copy(
                            isExporting = false,
                            exportResult = ExportResult.Error(error.message)
                        )
                    }
                }
            )
        }
    }
}

data class ExportUiState(
    val selectedModules: Set<ModuleType> = ModuleType.values().toSet(),
    val dateRange: DateRange = DateRange.ALL,
    val isExporting: Boolean = false,
    val progress: Float = 0f,
    val progressMessage: String = "",
    val exportResult: ExportResult? = null
)
```

#### 5.2 新的UI界面（2小时）
```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BackupExportScreen(
    onNavigateBack: () -> Unit,
    viewModel: BackupExportViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val launcher = rememberLauncherForActivityResult(
        ActivityResultContracts.CreateDocument("application/zip")
    ) { uri ->
        uri?.let { viewModel.exportData(it) }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("数据导出") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.ArrowBack, "返回")
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
        ) {
            // 模块选择
            ModuleSelectionSection(
                selectedModules = uiState.selectedModules,
                onModuleToggle = { module ->
                    viewModel.toggleModule(module)
                }
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // 日期范围选择
            DateRangeSection(
                selectedRange = uiState.dateRange,
                onRangeSelected = { range ->
                    viewModel.selectDateRange(range)
                }
            )
            
            Spacer(modifier = Modifier.weight(1f))
            
            // 导出按钮
            Button(
                onClick = {
                    launcher.launch("CC小记备份_${getCurrentDate()}.zip")
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = !uiState.isExporting && uiState.selectedModules.isNotEmpty()
            ) {
                if (uiState.isExporting) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(16.dp),
                        strokeWidth = 2.dp
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("导出中... ${(uiState.progress * 100).toInt()}%")
                } else {
                    Icon(Icons.Default.CloudUpload, null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("开始导出")
                }
            }
            
            // 进度信息
            if (uiState.progressMessage.isNotEmpty()) {
                Text(
                    text = uiState.progressMessage,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }
        }
    }
    
    // 处理导出结果
    uiState.exportResult?.let { result ->
        when (result) {
            is ExportResult.Success -> {
                LaunchedEffect(result) {
                    // 显示成功提示
                }
            }
            is ExportResult.Error -> {
                LaunchedEffect(result) {
                    // 显示错误提示
                }
            }
        }
    }
}
```

### Phase 6: 测试、优化和恢复（4小时）

#### 6.1 单元测试（1.5小时）
```kotlin
class TransactionMapperTest {
    @Test
    fun `test CSV export format matches Qianji`() {
        val transaction = TransactionEntity(
            id = "1",
            amount = 2550, // 25.50元
            type = TransactionType.EXPENSE,
            categoryId = "food",
            accountId = "wechat",
            date = LocalDateTime.parse("2025-08-01T10:30:00"),
            note = "午餐",
            tags = listOf("工作餐")
        )
        
        val csvLine = mapper.toCsvLine(transaction)
        
        // 验证钱迹格式
        assertTrue(csvLine.contains("cc_"))
        assertTrue(csvLine.contains("25.50"))
        assertTrue(csvLine.contains("支出"))
        assertTrue(csvLine.contains("CNY"))
    }
}
```

#### 6.2 集成测试（1.5小时）
- 完整的导出导入流程测试
- 大数据量性能测试（10万条记录）
- 内存使用监控
- ZIP压缩率验证

#### 6.3 恢复功能（1小时）
1. **移除升级提示UI**
   - 删除FeatureUpgradeScreen组件
   - 恢复DataExportScreen和DataImportScreen的正常实现

2. **恢复导航**
   ```kotlin
   // ProfileScreen.kt
   NavigationItem(
       icon = Icons.Default.CloudUpload,
       title = "数据导出",
       onClick = { navController.navigate(Screen.DataExport.route) }
   )
   
   NavigationItem(
       icon = Icons.Default.CloudDownload,
       title = "数据导入",
       onClick = { navController.navigate(Screen.DataImport.route) }
   )
   ```

3. **更新NavGraph**
   ```kotlin
   composable(Screen.DataExport.route) {
       BackupExportScreen(
           onNavigateBack = { navController.popBackStack() }
       )
   }
   
   composable(Screen.DataImport.route) {
       BackupImportScreen(
           onNavigateBack = { navController.popBackStack() }
       )
   }
   ```


## ⚠️ 风险和注意事项（先推墙方案）

### 1. 功能不可用风险
- **影响范围**：导入导出功能将有26小时完全不可用
- **用户影响**：期间用户无法备份或恢复数据
- **缓解措施**：
  - 提前发布公告，明确恢复时间
  - 提供清晰的升级提示UI
  - 可考虑提供临时的数据库文件导出方案

### 2. 技术实施风险
- **删除错误**：可能误删其他模块依赖的文件
  - **缓解**：使用IDE的"Find Usages"功能仔细检查
  - **备份**：创建git标签，可快速恢复
- **新系统bug**：从零开始可能引入新问题
  - **缓解**：充分的单元测试和集成测试
  - **分阶段发布**：先内测，确认稳定后再发布

### 3. 时间超期风险
- **预估时间**：26小时（Phase 1: 4小时 + Phase 2-6: 22小时）
- **可能延期**：新系统调试可能需要额外时间
- **缓解措施**：
  - 预留20%的缓冲时间
  - 可以先恢复导出功能，再恢复导入功能

### 4. 技术细节风险
- **CSV兼容性**：钱迹格式可能有版本差异
- **JSON序列化**：复杂对象（如树形结构）需要特殊处理
- **内存管理**：流式处理需要正确实现避免OOM
- **文件权限**：Android 11+的存储权限需要特殊处理

## 🎯 成功标准

1. **功能完整性**
   - [ ] 所有模块数据都能正确导出到CSV+JSON
   - [ ] 所有模块数据都能从ZIP文件正确导入
   - [ ] 支持钱迹CSV格式兼容导入
   - [ ] 支持追加和覆盖两种导入模式

2. **性能指标**
   - [ ] 10万条记录导出时间 < 20秒
   - [ ] 内存峰值占用 < 50MB
   - [ ] 文件大小比原方案减小30%+

3. **用户体验**
   - [ ] 交易记录CSV可在Excel中正常查看
   - [ ] 数据结构清晰，类似钱迹体验
   - [ ] 错误提示明确，指导性强
   - [ ] 支持从钱迹等软件迁移数据

4. **代码质量**
   - [ ] 代码覆盖率 > 80%
   - [ ] 零编译警告
   - [ ] 完整的错误处理

## 📅 时间线（先推墙方案）

### 总体安排
- **总工期**：26小时（约4个工作日）
- **功能不可用期**：整个开发期间

### 详细时间分配
- **Day 1 上午**：Phase 1 - 推倒（4小时）
  - 备份代码、创建升级UI、删除旧系统、验证
- **Day 1 下午**：Phase 2 - 搭建基础框架（3小时）
  - 创建包结构、定义接口、配置依赖注入
- **Day 2**：Phase 3 - 实现核心功能（8小时）
  - BackupMetadata、CsvExporter、JsonExporter、导入器
- **Day 3 上午**：Phase 4 - 模块映射器（6小时）
  - TransactionMapper、其他模块映射器
- **Day 3 下午**：Phase 5 - UI层实现（4小时）
  - ViewModel、Screen界面
- **Day 4 上午**：Phase 6 - 测试、优化和恢复（4小时）
  - 单元测试、集成测试、恢复功能

### 里程碑
- **8月1日 12:00**：旧系统完全删除
- **8月2日 18:00**：核心功能实现完成
- **8月3日 18:00**：UI层实现完成
- **8月4日 12:00**：功能恢复上线

## 🔄 后续计划

1. **版本2.1**：支持更多第三方软件CSV格式导入（随手记、网易有钱等）
2. **版本2.2**：支持选择性导出（日期范围、特定账户等）
3. **版本2.3**：添加数据分析功能（生成统计CSV报表）

## 🎯 方案优势总结

方案核心优势：
- ✅ **零依赖**：减少APK体积和潜在风险
- ✅ **开发高效**：架构清晰，实现简单
- ✅ **更兼容**：支持钱迹等软件数据迁移
- ✅ **更直观**：记账数据可直接在Excel中查看
- ✅ **更小巧**：文件体积更小，传输更快

---

## 🎯 方案总结：先推墙，再砌墙

### 核心决策
- **方案选择**：CSV+JSON混合方案（交易记录用CSV，其他用JSON）
- **实施策略**：先推墙，再砌墙（彻底删除旧系统后重建）
- **兼容目标**：钱迹CSV格式，便于用户迁移

### 关键优势
1. **代码纯净**：新系统不受旧代码影响，设计更优
2. **用户友好**：交易记录可直接Excel查看，类似钱迹
3. **性能优异**：流式处理，内存占用低
4. **零依赖**：使用Android原生API，无第三方库风险

### 实施要点
- Phase 1：推倒旧系统（4小时）
- Phase 2-6：构建新系统（22小时）
- 总工期：26小时，功能不可用期：26小时

---

**最后更新时间**：2025-08-01 12:00  
**状态**：方案确定，采用"先推墙，再砌墙"策略实施CSV+JSON方案  
**负责人**：开发团队  
**预计完成时间**：2025-08-04 12:00