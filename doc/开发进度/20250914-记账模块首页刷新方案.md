# 记账模块首页刷新长期方案（Room 热流 + 响应式订阅）

版本：v1.0（2025-09-14）

负责人：待定  审阅：待定

## 背景与目标

- 背景：当前添加/编辑交易后返回首页，首页列表不自动刷新，需重新进入模块才可见更新。
- 目标：将首页数据源改为 Room Flow（热流），通过响应式订阅随数据变化自动更新 UI，无需手动刷新或事件回传。

## 现状与问题

- 首页 `LedgerViewModel` 使用分页一次性加载（`getTransactionsPaginated*`），非热流，返回后不会自动重新拉取。
- 增删改交易通过仓库写入数据库，但首页未订阅数据库变更。
- 月度统计也非热流（可分阶段改造）。

## 设计原则

- 响应式：使用 Room `Flow<List<Entity>>` 订阅“账本 + 时间范围（起止毫秒）(+账户可选)”的交易变化。
- 精准：查询限定在当前账本与所选月份范围，避免全量订阅带来的性能开销。
- 渐进：优先改造首页交易列表为热流；月度统计随后改造为热流（第二阶段）。
- 兼容：保留现有刷新方法作为兜底；功能稳定后逐步移除事件桥接和显式刷新。

## 方案总览

1) DAO 新增按账本+时间范围的热流查询。
2) Repository 直通热流并完成实体→领域模型映射。
3) ViewModel 用 `flatMapLatest` 组合“所选账本 + 所选月份（起止毫秒）(+账户过滤）”→ 订阅仓库热流，更新 UI。
4) UI 通过 `collectAsStateWithLifecycle()` 渲染；返回首页时无需主动刷新。

## 分阶段实施

### 阶段 A：首页交易列表热流化（必须）

1. TransactionDao 新增热流查询

```
// feature/ledger/data/local/dao/TransactionDao.kt
@Query("""
  SELECT * FROM transactions
  WHERE ledgerId = :ledgerId AND isDeleted = 0
    AND (:accountId IS NULL OR accountId = :accountId)
    AND createdAt >= :startTime AND createdAt < :endTime
  ORDER BY createdAt DESC
""")
fun getTransactionsByLedgerAndDateRange(
  ledgerId: String,
  startTime: Long,
  endTime: Long,
  accountId: String? = null
): kotlinx.coroutines.flow.Flow<List<TransactionEntity>>
```

（可选）多账本版本：`getTransactionsByLedgersAndDateRange(ledgerIds: List<String>, ...)`。

2. Repository 新增热流方法

```
// feature/ledger/domain/repository/TransactionRepository.kt
fun getTransactionsByLedgerFlow(
  ledgerId: String,
  startMillis: Long,
  endMillis: Long,
  accountId: String? = null
): Flow<List<Transaction>>

// feature/ledger/data/repository/TransactionRepositoryImpl.kt
override fun getTransactionsByLedgerFlow(...): Flow<List<Transaction>> =
  transactionDao.getTransactionsByLedgerAndDateRange(ledgerId, startMillis, endMillis, accountId)
    .map { entities ->
      // 简化：沿用当前映射策略（必要时后续优化为 JOIN 附带分类信息）
      entities.map { entity -> toDomainModelWithEnrichment(entity, /*category*/ null) }
    }
    .flowOn(Dispatchers.IO)
```

注意：`toDomainModelWithEnrichment` 内部如有逐条 DAO 查询，可在后续优化为 JOIN 查询（性能优化见“后续优化”）。

3. LedgerViewModel 改为响应式订阅

```
// 关键字段
private val _selectedMonth = MutableStateFlow(YearMonth.now())
private val _selectedLedgerId = MutableStateFlow<String?>(null) // 从 UI 状态同步
private val _selectedAccountId = MutableStateFlow<String?>(null) // 过滤可选

// 组合时间范围计算
private fun YearMonth.toMillisRange(): Pair<Long, Long> { ... } // 现有实现可复用

// 热流订阅（在 init 或专用函数中启动）
init {
  viewModelScope.launch {
    combine(_selectedLedgerId.filterNotNull(), _selectedMonth) { ledgerId, ym ->
      Triple(ledgerId, ym, ym.toMillisRange())
    }.flatMapLatest { (ledgerId, ym, range) ->
      val (start, end) = range
      transactionRepository.getTransactionsByLedgerFlow(
        ledgerId = ledgerId,
        startMillis = start,
        endMillis = end,
        accountId = _uiState.value.selectedAccountId?.takeUnless { it.startsWith("default_account_") }
      )
    }.collect { txs ->
      _uiState.update { it.copy(transactions = txs, isLoading = false) }
      // 触发月度统计刷新（阶段 A 保持现状为一次性 suspend）
      loadMonthlySummary()
    }
  }
}
```

同时：
- `selectMonth()` 仅更新 `_selectedMonth`。
- 账本切换 `selectLedger()` 更新 `_selectedLedgerId`，其余逻辑保持（保存偏好+统计刷新）。
- 移除或不再使用分页页码状态（`currentPage/pageSize/hasMore`）在首页场景。

4. LedgerScreen 无需改动交互，仅保持 `collectAsStateWithLifecycle()`，即可随 Flow 自动刷新。

5. 保留兜底（可选）

- 保留 `refreshTransactions()` 以应对异常情况（例如统计刷新失败时重拉）。
- 如已实现“保存成功事件桥接”，可逐步移除。

### 阶段 B：月度统计热流化（优化）

1. DAO 新增统计热流：

```
@Query("""
  SELECT SUM(CASE WHEN c.type='INCOME' THEN t.amountCents ELSE 0 END) AS income,
         SUM(CASE WHEN c.type='EXPENSE' THEN t.amountCents ELSE 0 END) AS expense
  FROM transactions t JOIN categories c ON t.categoryId=c.id
  WHERE t.ledgerId=:ledgerId AND t.isDeleted=0
    AND t.createdAt>=:start AND t.createdAt<:end AND t.transferId IS NULL
""")
fun getMonthlyIncomesAndExpensesByLedgerFlow(
  ledgerId: String,
  start: Long,
  end: Long
): Flow<com.ccxiaoji.feature.ledger.data.local.dao.IncomeExpensePair>
```

2. Repository 暴露 Flow；ViewModel 用 `combine` 与交易热流共享相同时间范围，订阅后同步更新 `monthlyIncome/Expense`。

### 阶段 C：清理临时逻辑（收尾）

- 移除或关闭“保存成功事件桥接”“onResume 兜底刷新”。
- 删除首页分页相关字段与死代码（仅首页；保留其他场景的分页能力）。

## 详细改动清单（文件级）

1) `feature/ledger/data/local/dao/TransactionDao.kt`
- 新增 `getTransactionsByLedgerAndDateRange(...) : Flow<List<TransactionEntity>>`。
- （可选）新增多账本版本。

2) `feature/ledger/domain/repository/TransactionRepository.kt`
- 新增接口：`getTransactionsByLedgerFlow(ledgerId, startMillis, endMillis, accountId?)`。

3) `feature/ledger/data/repository/TransactionRepositoryImpl.kt`
- 实现上述 Flow 方法；在 `map` 中完成实体→领域模型映射；`flowOn(Dispatchers.IO)`。

4) `feature/ledger/presentation/viewmodel/LedgerViewModel.kt`
- 新增 `_selectedLedgerId`，与 UI/偏好同步。
- 用 `combine + flatMapLatest` 订阅仓库 Flow；在 `collect` 中更新 `_uiState.transactions`。
- `selectMonth/selectLedger` 仅更新 state；触发链式刷新。
- `loadTransactions()` 在首页路径废弃或仅兜底调用。

5) `feature/ledger/presentation/screen/ledger/LedgerScreen.kt`
- 无需改动业务逻辑；保持 `collectAsStateWithLifecycle()`。

## 测试与验收

用例（关键场景）：
- 新增交易（当前账本 & 当前月份内）→ 返回首页列表自动出现新交易；月度统计同步变化。
- 编辑交易（修改金额/分类/账户/日期）→ 列表与统计自动变化；跨月/跨账本编辑后，当前首页列表随筛选条件自动增删。
- 删除交易 → 列表与统计自动减少。
- 切换账本/切换月份/账户过滤 → 列表与统计立即切换到新订阅的数据。

性能与稳定：
- 大月数据（>5k 笔）滚动体验流畅；数据库查询限制在 `ledgerId + 月份范围`。
- 无死锁/主线程卡顿；Flow 在 IO 线程执行查询与映射。

验收标准：
- 不进行任何手动刷新或返回事件桥接，首页在上述操作后稳定自动更新。

## 风险与对策

- 逐条映射查询分类信息可能带来 N+1 查询风险：
  - 短期：沿用现有实现（已在 IO 线程）；
  - 中期优化：将 DAO 查询改造为 JOIN 返回分类字段，减少额外查询。
- 与旧分页逻辑共存期的状态错配：
  - 保留 `isLoading`，在 ledger/month 切换时短暂置位；去除 `currentPage/hasMore` 在首页场景的使用。
- 统计非热流：
  - 阶段 A 内在交易变更时调用 `loadMonthlySummary()`；阶段 B 改为热流后移除此调用。

## 回滚策略

- 新增方法与订阅代码均为增量变更；保留旧的 `loadTransactions()` 路径。
- 如出现问题，可通过 Feature Flag（如 `enableReactiveLedgerHome`）快速切换回旧逻辑。

## 里程碑与工期（预估）

- 阶段 A：1–1.5 天
  - DAO/Repo/ViewModel 改造 + 自测回归。
- 阶段 B：0.5–1 天
  - 统计热流化 + 自测。
- 阶段 C：0.5 天
  - 清理临时逻辑与代码。

## 开发Checklist（避免跑偏）

- [ ] 为 DAO 添加热流查询（含 unit test/instrumented test）。
- [ ] Repository 返回领域模型 Flow；保证在 IO 线程。
- [ ] ViewModel 使用 `combine + flatMapLatest` 订阅，移除分页状态。
- [ ] 首页 UI 无需改动交互，仅观察状态。
- [ ] 交易变更后无需手动刷新；回归增删改 + 跨月/跨账本编辑场景。
- [ ] 评估并记录分类信息映射的性能，酌情列入 JOIN 优化任务。

## 后续优化（非必需）

- 将月度统计改为 Flow，并与交易热流共用时间范围（避免重复逻辑）。
- 将 `toDomainModelWithEnrichment` 的分类信息通过 DAO JOIN 一次性返回，避免 N+1 查询。
- 为查询涉及字段（`ledgerId, createdAt, userId, accountId`）确认/补充索引。

