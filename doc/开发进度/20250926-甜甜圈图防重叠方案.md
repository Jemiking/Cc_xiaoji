# 甜甜圈图标签防重叠方案

## 1. 问题背景

### 现状描述
在记账应用的分类报表页面中，甜甜圈图（Donut Chart）的标签存在严重的重叠问题，特别是当多个小比例分类聚集在同一侧时（如左侧的"买菜3%"、"超市5%"、"下馆子6%"等）。

### 问题分析
当前实现的主要缺陷：
1. **直接使用径向终点Y坐标** - 没有考虑文字高度（约12-15px）
2. **没有碰撞检测机制** - 无法识别标签是否会重叠
3. **没有位置调整策略** - 即使检测到重叠也无法调整
4. **当多个分类角度接近时**，它们的Y坐标差值小于文字高度，导致严重重叠

## 2. 解决方案概述

采用**三阶段绘制流程**解决标签重叠问题：

1. **收集阶段**：遍历所有分类，计算并存储标签信息
2. **调整阶段**：检测重叠并智能调整标签位置
3. **绘制阶段**：根据调整后的位置绘制标签和引导线

## 3. 详细实现方案

### 3.1 数据结构设计

```kotlin
/**
 * 标签信息数据类
 * 存储每个标签的位置和绘制信息
 */
data class LabelInfo(
    val entry: CategoryEntry,           // 原始分类数据
    val angle: Float,                   // 扇形中心角度
    val anchorX: Float,                 // 锚点X坐标（圆环上的连接点）
    val anchorY: Float,                 // 锚点Y坐标
    val originalY: Float,               // 原始Y位置（径向延伸后的位置）
    var adjustedY: Float,               // 调整后的Y位置（防重叠后）
    val horizontalEndX: Float,          // 水平线终点X坐标
    val isLeftSide: Boolean,           // 是否在左侧（用于文字对齐）
    val text: String                    // 显示文本（名称+百分比）
)
```

### 3.2 主绘制流程改造

```kotlin
@Composable
private fun Donut(entries: List<CategoryEntry>, modifier: Modifier = Modifier) {
    // ... 其他代码保持不变 ...

    Canvas(modifier = modifier) {
        drawIntoCanvas { canvas ->
            // 1. 绘制甜甜圈图本体
            drawDonutChart(/*...*/)

            // 2. 使用新的防重叠标签系统
            drawLabelsWithAntiOverlap(
                list = entries,
                normalized = normalized,
                angles = angles,
                centerX = centerX,
                centerY = centerY,
                radius = radius,
                rotationAngle = rotationAngle
            )
        }
    }
}

/**
 * 带防重叠功能的标签绘制系统
 */
private fun DrawScope.drawLabelsWithAntiOverlap(
    list: List<CategoryEntry>,
    normalized: List<Float>,
    angles: List<Pair<Float, Float>>,
    centerX: Float,
    centerY: Float,
    radius: Float,
    rotationAngle: Float
) {
    val threshold = 0.02f               // 最小显示阈值（2%）
    val baseExtension = 35f             // 基础径向延伸长度
    val minHorizontal = 25f             // 最小水平延伸长度
    val maxHorizontal = 55f             // 最大水平延伸长度
    val minLabelSpacing = 16f           // 最小标签间距（文字高度+间隙）

    // 阶段1：收集所有标签信息
    val leftLabels = mutableListOf<LabelInfo>()
    val rightLabels = mutableListOf<LabelInfo>()

    list.forEachIndexed { index, entry ->
        if (normalized[index] >= threshold) {
            val (startAngle, sweepAngle) = angles[index]
            val midAngle = startAngle + sweepAngle / 2f
            val angleRad = Math.toRadians(midAngle.toDouble())

            // 计算锚点（圆环上的点）
            val anchorX = centerX + radius * cos(angleRad).toFloat()
            val anchorY = centerY + radius * sin(angleRad).toFloat()

            // 计算径向延伸点
            val radialEndX = centerX + (radius + baseExtension) * cos(angleRad).toFloat()
            val radialEndY = centerY + (radius + baseExtension) * sin(angleRad).toFloat()

            // 智能计算水平延伸长度（根据垂直位置动态调整）
            val verticalDistance = kotlin.math.abs(kotlin.math.sin(angleRad)).toFloat()
            val horizontalLength = minHorizontal + (maxHorizontal - minHorizontal) * (1f - verticalDistance)

            // 判断左右侧
            val isLeftSide = midAngle > 90f && midAngle < 270f
            val horizontalEndX = if (isLeftSide) {
                radialEndX - horizontalLength
            } else {
                radialEndX + horizontalLength
            }

            // 创建标签信息对象
            val labelInfo = LabelInfo(
                entry = entry,
                angle = midAngle,
                anchorX = anchorX,
                anchorY = anchorY,
                originalY = radialEndY,
                adjustedY = radialEndY,  // 初始值等于原始值
                horizontalEndX = horizontalEndX,
                isLeftSide = isLeftSide,
                text = "${entry.name} ${(entry.percent * 100).toInt()}%"
            )

            // 按左右分组收集
            if (isLeftSide) {
                leftLabels.add(labelInfo)
            } else {
                rightLabels.add(labelInfo)
            }
        }
    }

    // 阶段2：调整标签位置避免重叠
    adjustLabelPositions(leftLabels, minLabelSpacing)
    adjustLabelPositions(rightLabels, minLabelSpacing)

    // 阶段3：绘制调整后的标签和引导线
    (leftLabels + rightLabels).forEach { label ->
        drawAdjustedLabel(label, radius, baseExtension)
    }
}
```

### 3.3 防重叠算法实现

```kotlin
/**
 * 调整标签位置以避免重叠
 * 使用局部调整法：尽量保持原始位置，只在必要时移动
 */
private fun adjustLabelPositions(
    labels: MutableList<LabelInfo>,
    minSpacing: Float
) {
    if (labels.size <= 1) return

    // 按Y坐标排序（从上到下）
    labels.sortBy { it.originalY }

    // 从上到下检查重叠，必要时向下移动
    for (i in 1 until labels.size) {
        val prevLabel = labels[i - 1]
        val currLabel = labels[i]
        val requiredY = prevLabel.adjustedY + minSpacing

        if (currLabel.adjustedY < requiredY) {
            // 发生重叠，向下移动当前标签
            currLabel.adjustedY = requiredY
        }
    }

    // 反向检查，处理累积偏移过大的情况
    // 计算整体偏移中心
    val totalOffset = labels.sumOf { (it.adjustedY - it.originalY).toDouble() }.toFloat()
    val averageOffset = totalOffset / labels.size

    // 如果整体偏移过大，进行回调
    if (kotlin.math.abs(averageOffset) > 20f) {
        labels.forEach { label ->
            label.adjustedY -= averageOffset / 2f  // 部分回调，保持相对位置
        }
    }
}

/**
 * 备选方案：均匀分布法
 * 适用于标签密集的情况，将所有标签均匀分布
 */
private fun adjustLabelPositionsUniform(
    labels: MutableList<LabelInfo>,
    minSpacing: Float
) {
    if (labels.size <= 1) return

    // 按原始Y坐标排序
    labels.sortBy { it.originalY }

    // 计算标签组的中心位置
    val centerY = labels.map { it.originalY }.average().toFloat()

    // 计算总高度
    val totalHeight = labels.size * minSpacing

    // 均匀分布
    val startY = centerY - totalHeight / 2f + minSpacing / 2f

    labels.forEachIndexed { index, label ->
        label.adjustedY = startY + index * minSpacing
    }
}
```

### 3.4 优化的引导线绘制

```kotlin
/**
 * 绘制单个调整后的标签
 * 支持两种引导线样式：L形（未调整）和三段式（有调整）
 */
private fun DrawScope.drawAdjustedLabel(
    label: LabelInfo,
    radius: Float,
    baseExtension: Float
) {
    val angleRad = Math.toRadians(label.angle.toDouble())
    val centerX = size.width / 2f
    val centerY = size.height / 2f

    // 计算径向延伸点
    val radialEndX = centerX + (radius + baseExtension) * cos(angleRad).toFloat()
    val radialEndY = centerY + (radius + baseExtension) * sin(angleRad).toFloat()

    // 判断是否需要垂直调整
    val needsVerticalAdjustment = kotlin.math.abs(label.adjustedY - radialEndY) > 2f

    if (!needsVerticalAdjustment) {
        // 标准L形引导线（无需调整）
        // 1. 径向段
        drawLine(
            color = Color(0xFFBBBBBB),
            start = Offset(label.anchorX, label.anchorY),
            end = Offset(radialEndX, radialEndY),
            strokeWidth = 1f
        )
        // 2. 水平段
        drawLine(
            color = Color(0xFFBBBBBB),
            start = Offset(radialEndX, radialEndY),
            end = Offset(label.horizontalEndX, label.adjustedY),
            strokeWidth = 1f
        )
    } else {
        // 三段式引导线（有垂直调整）
        val verticalX = radialEndX + if (label.isLeftSide) -10f else 10f

        // 1. 径向段
        drawLine(
            color = Color(0xFFBBBBBB),
            start = Offset(label.anchorX, label.anchorY),
            end = Offset(radialEndX, radialEndY),
            strokeWidth = 1f
        )

        // 2. 垂直调整段
        drawLine(
            color = Color(0xFFBBBBBB),
            start = Offset(radialEndX, radialEndY),
            end = Offset(verticalX, label.adjustedY),
            strokeWidth = 1f
        )

        // 3. 水平段
        drawLine(
            color = Color(0xFFBBBBBB),
            start = Offset(verticalX, label.adjustedY),
            end = Offset(label.horizontalEndX, label.adjustedY),
            strokeWidth = 1f
        )
    }

    // 绘制圆点标记
    drawCircle(
        color = label.entry.color,
        radius = 2f,
        center = Offset(label.anchorX, label.anchorY)
    )

    // 绘制文字
    drawIntoCanvas { canvas ->
        val paint = Paint().apply {
            color = ReportTokens.Palette.TextMuted.toArgb()
            textSize = 10.sp.toPx()
            isAntiAlias = true
            textAlign = if (label.isLeftSide) Paint.Align.RIGHT else Paint.Align.LEFT
        }

        val textX = if (label.isLeftSide) {
            label.horizontalEndX - 5f
        } else {
            label.horizontalEndX + 5f
        }

        canvas.nativeCanvas.drawText(
            label.text,
            textX,
            label.adjustedY + paint.textSize / 3f,  // 垂直居中
            paint
        )
    }
}
```

### 3.5 参数配置

```kotlin
/**
 * 标签布局配置参数
 * 可根据实际效果微调
 */
object LabelLayoutConfig {
    const val MIN_LABEL_SPACING = 16f          // 最小垂直间距（px）
    const val MAX_VERTICAL_ADJUSTMENT = 50f     // 最大垂直调整量（px）
    const val RADIAL_EXTENSION = 35f           // 径向延伸长度（px）
    const val MIN_HORIZONTAL_EXT = 25f         // 最小水平延伸（px）
    const val MAX_HORIZONTAL_EXT = 55f         // 最大水平延伸（px）
    const val LABEL_TEXT_SIZE = 10f            // 标签文字大小（sp）
    const val MERGE_THRESHOLD = 0.02f          // 合并阈值（2%）
    const val LINE_COLOR = 0xFFBBBBBB          // 引导线颜色
    const val DOT_RADIUS = 2f                  // 圆点半径（px）
    const val TEXT_PADDING = 5f                // 文字与线的间距（px）
}
```

## 4. 额外优化策略

### 4.1 智能合并小分类
当分类过多时，可以将小于2%的分类合并为"其他"：

```kotlin
fun mergeSmallCategories(
    entries: List<CategoryEntry>,
    threshold: Float = 0.02f
): List<CategoryEntry> {
    val (large, small) = entries.partition { it.percent >= threshold }

    return if (small.isNotEmpty()) {
        val otherPercent = small.sumOf { it.percent }
        val otherAmount = "¥%.2f".format(
            small.sumOf {
                it.amount.replace("¥", "").replace(",", "").toFloatOrNull() ?: 0f
            }
        )

        large + CategoryEntry(
            name = "其他",
            amount = otherAmount,
            percent = otherPercent,
            color = Color(0xFF999999),
            icon = CategoryIcon.Other
        )
    } else {
        large
    }
}
```

### 4.2 动态字体大小
根据标签数量动态调整字体大小：

```kotlin
fun getDynamicFontSize(labelCount: Int): Float {
    return when {
        labelCount <= 6 -> 11.sp.toPx()
        labelCount <= 10 -> 10.sp.toPx()
        labelCount <= 15 -> 9.sp.toPx()
        else -> 8.sp.toPx()
    }
}
```

## 5. 实施步骤

1. **备份当前代码**：保存 `CategoryDonutCard.kt` 的当前版本
2. **添加数据结构**：在文件顶部添加 `LabelInfo` 数据类
3. **重构绘制逻辑**：将现有的标签绘制代码替换为三阶段流程
4. **实现防重叠算法**：添加 `adjustLabelPositions` 函数
5. **测试验证**：使用不同数据集测试，确保无重叠
6. **性能优化**：如有必要，优化算法性能

## 6. 测试用例

### 测试场景1：密集标签
```kotlin
// 10个以上小比例分类聚集在左侧
val testData = listOf(
    CategoryEntry("分类1", "¥100", 0.03f, color1, icon1),
    CategoryEntry("分类2", "¥120", 0.04f, color2, icon2),
    CategoryEntry("分类3", "¥90", 0.03f, color3, icon3),
    // ... 更多相近角度的分类
)
```

### 测试场景2：极端分布
```kotlin
// 一个大分类+多个小分类
val testData = listOf(
    CategoryEntry("主要支出", "¥5000", 0.70f, color1, icon1),
    CategoryEntry("小额1", "¥50", 0.01f, color2, icon2),
    CategoryEntry("小额2", "¥60", 0.01f, color3, icon3),
    // ...
)
```

## 7. 注意事项

1. **性能考虑**：防重叠算法在每次绘制时执行，需确保效率
2. **视觉平衡**：调整后的标签应保持整体视觉平衡
3. **引导线美观**：三段式引导线应平滑过渡，避免锐角
4. **响应式设计**：考虑不同屏幕尺寸的适配

## 8. 后续优化方向

- [ ] 添加动画过渡效果
- [ ] 支持标签折叠/展开
- [ ] 智能标签密度检测
- [ ] 自适应布局策略
- [ ] 标签优先级排序

---

*文档创建时间：2025-09-26*
*作者：Claude Code Assistant*
*版本：v1.0*