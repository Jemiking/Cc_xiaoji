# Excel数据导入导出问题修复方案

## 文档信息
- **创建日期**: 2025-08-17
- **作者**: Claude Code with O3 Analysis
- **状态**: 已完成
- **预计工期**: 7-10天
- **最后更新**: 2025-08-17
- **完成时间**: 2025-08-17

## 实施进度
- ✅ 第一阶段：解决兼容性问题（已完成）
  - ✅ 创建SafeExcelReader.kt
  - ✅ SimpleXlsxReader.kt已存在且更完整
- ✅ 第二阶段：统一数据格式（已完成）
  - ✅ 创建ExcelColumnMappings.kt
  - ✅ 修改ExcelManager.kt使用统一列名
- ✅ 第三阶段：实现高性能导入（已完成）
  - ✅ 创建EnhancedBatchImportProcessor.kt
  - ✅ 创建StreamingExcelImportManager.kt
- ✅ 第四阶段：数据完整性保障（已完成）
  - ✅ 创建DataIntegrityService.kt
  - ✅ 创建ImportValidator.kt
- ✅ 第五阶段：用户体验优化（已完成）
  - ✅ 创建ImportErrorDialog.kt
  - ✅ 创建ImportPreviewScreen.kt

## 完成总结
- **状态**: 全部完成
- **完成时间**: 2025-08-17
- **创建文件数**: 9个新文件，1个修改文件
- **待编译验证**: 需要在Android Studio中编译验证所有修改

## 验证结果（2025-08-17）
### 文件存在性验证
- ✅ SafeExcelReader.kt - 已存在于 `app/src/main/kotlin/com/ccxiaoji/app/data/excel/`
- ✅ SimpleXlsxReader.kt - 已存在于 `app/src/main/kotlin/com/ccxiaoji/app/data/excel/`
- ✅ ExcelColumnMappings.kt - 已存在于 `app/src/main/kotlin/com/ccxiaoji/app/data/excel/mapping/`
- ✅ EnhancedBatchImportProcessor.kt - 已存在于 `app/src/main/kotlin/com/ccxiaoji/app/data/excel/`
- ✅ StreamingExcelImportManager.kt - 已存在于 `app/src/main/kotlin/com/ccxiaoji/app/data/excel/`
- ✅ DataIntegrityService.kt - 已存在于 `app/src/main/kotlin/com/ccxiaoji/app/data/excel/`
- ✅ ImportValidator.kt - 已存在于 `app/src/main/kotlin/com/ccxiaoji/app/data/excel/`
- ✅ ImportErrorDialog.kt - 已存在于 `app/src/main/java/com/ccxiaoji/app/presentation/ui/components/`
- ✅ ImportPreviewScreen.kt - 已存在于 `app/src/main/java/com/ccxiaoji/app/presentation/ui/screens/`

### 实施总结
- **所有文件创建完成**：文档中提到的9个新文件全部已创建并存在于正确的位置
- **文件组织结构正确**：数据处理相关文件位于kotlin目录，UI相关文件位于java目录
- **包结构清晰**：映射文件单独放在mapping子包中，便于管理
- **编译验证**：请开发者在Android Studio中手动编译验证实现的正确性

## 一、问题背景

### 1.1 项目概述
CC小记是一个Android生活管理应用，包含待办、习惯、记账、排班、计划5个功能模块。使用Apache POI库进行Excel文件的导入导出。

### 1.2 当前问题汇总

#### 兼容性问题
- Apache POI依赖java.awt.*，在Android上导致`NoClassDefFoundError`
- 导出功能已部分修复（移除autoSizeColumn），但导入仍有风险
- 日期解析、公式计算可能失败

#### 数据一致性问题
| 模块 | 导出列名 | 导入查找列名 | 影响 |
|------|----------|--------------|------|
| 待办任务 | 描述 | 任务描述 | 数据丢失 |
| 习惯记录 | 目标次数 | 目标频率 | 数据丢失 |
| 习惯记录 | 创建时间 | 创建日期 | 数据丢失 |
| 待办任务 | - | 标签 | 缺少导出 |

#### 性能问题
- 批量导入时逐条插入，未使用DAO层批量API
- 一次性加载整个Excel到内存，大文件可能OOM
- TransactionDao有`insertTransactions(List<TransactionEntity>)`但未使用

#### 数据完整性问题
- 已完成任务导入后变成未完成状态
- 习惯统计信息（连续天数、历史最长）丢失
- 账户初始余额可能丢失

#### 错误处理问题
- 单条记录失败不会中止导入
- 错误信息不够详细，用户难以定位问题

## 二、O3模型分析核心洞察

### 2.1 问题本质
> "在缺失 java.awt.* 的 Android 运行时内高效解析大体积 XLSX，同时保证数据完整性和用户体验。"

### 2.2 核心挑战
1. **技术挑战**: POI在Android上的兼容性受限
2. **架构挑战**: 导入导出列映射不一致
3. **性能挑战**: 全部加载 + 单条插入的瓶颈
4. **业务挑战**: 数据完整性与业务逻辑缺失

### 2.3 推荐方案
**POI StreamingReader + Room Batch Insert**
- 继续使用POI，但切换到轻量版本
- 采用SAX流式解析，避免内存问题
- 利用Room批量API提升性能
- 统一列映射确保数据一致性

## 三、技术方案

### 3.1 总体架构
```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│ SafeExcelReader │────▶│ ColumnMapping    │────▶│ BatchProcessor  │
│ (流式解析)      │     │ (统一映射)        │     │ (批量处理)      │
└─────────────────┘     └──────────────────┘     └─────────────────┘
         │                       │                          │
         ▼                       ▼                          ▼
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│ Validation      │     │ ErrorHandler     │     │ DataIntegrity   │
│ (数据验证)      │     │ (错误处理)        │     │ (完整性保障)     │
└─────────────────┘     └──────────────────┘     └─────────────────┘
```

### 3.2 依赖配置
```kotlin
// app/build.gradle.kts
dependencies {
    // 移除原有POI依赖
    // implementation("org.apache.poi:poi-ooxml:5.2.4")
    
    // 使用轻量级版本
    implementation("org.apache.poi:poi-ooxml-lite:5.2.4")
    implementation("org.apache.xmlbeans:xmlbeans:5.1.1") {
        exclude(group = "stax", module = "stax-api")
    }
    
    // Android兼容的XML解析
    implementation("com.fasterxml:aalto-xml:1.3.2")
}
```

## 四、具体实施步骤

### 第一阶段：解决兼容性问题（Day 1-2）

#### 4.1.1 创建安全的Excel读取器
创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/SafeExcelReader.kt`

```kotlin
package com.ccxiaoji.app.data.excel

import org.apache.poi.openxml4j.opc.OPCPackage
import org.apache.poi.xssf.eventusermodel.XSSFReader
import org.apache.poi.xssf.model.SharedStringsTable
import org.apache.poi.xssf.model.StylesTable
import org.xml.sax.InputSource
import org.xml.sax.XMLReader
import org.xml.sax.helpers.XMLReaderFactory
import java.io.InputStream
import javax.inject.Inject

/**
 * 安全的Excel读取器，使用SAX方式避免内存问题
 */
class SafeExcelReader @Inject constructor() {
    
    /**
     * 流式读取Excel文件
     * @param inputStream Excel文件输入流
     * @param sheetName 要读取的工作表名称，null表示读取第一个
     * @param onRowRead 每读取一行的回调
     */
    suspend fun readExcelStreaming(
        inputStream: InputStream,
        sheetName: String? = null,
        onRowRead: (rowIndex: Int, row: Map<String, Any?>) -> Unit
    ) {
        val pkg = OPCPackage.open(inputStream)
        try {
            val reader = XSSFReader(pkg)
            val sst = reader.sharedStringsTable
            val styles = reader.stylesTable
            
            val parser = XMLReaderFactory.createXMLReader()
            val handler = SheetHandler(sst, styles, onRowRead)
            parser.contentHandler = handler
            
            if (sheetName != null) {
                // 读取指定工作表
                val sheetIterator = reader.getSheetsData()
                while (sheetIterator.hasNext()) {
                    val sheet = sheetIterator.next()
                    val sheetRefName = getSheetName(reader, sheet)
                    if (sheetRefName == sheetName) {
                        parser.parse(InputSource(sheet))
                        break
                    }
                }
            } else {
                // 读取第一个工作表
                val sheetIterator = reader.getSheetsData()
                if (sheetIterator.hasNext()) {
                    parser.parse(InputSource(sheetIterator.next()))
                }
            }
        } finally {
            pkg.close()
        }
    }
    
    /**
     * 获取Excel文件结构信息（不读取具体数据）
     */
    suspend fun analyzeExcelStructure(inputStream: InputStream): ExcelFileStructure {
        val pkg = OPCPackage.open(inputStream)
        try {
            val reader = XSSFReader(pkg)
            val sheets = mutableListOf<SheetInfo>()
            
            val sheetIterator = reader.getSheetsData()
            var sheetIndex = 0
            while (sheetIterator.hasNext()) {
                val sheet = sheetIterator.next()
                val sheetName = getSheetName(reader, sheetIndex)
                
                // 快速统计行数
                var rowCount = 0
                val parser = XMLReaderFactory.createXMLReader()
                parser.contentHandler = RowCountHandler { rowCount++ }
                parser.parse(InputSource(sheet))
                
                sheets.add(SheetInfo(
                    index = sheetIndex,
                    name = sheetName,
                    rowCount = rowCount
                ))
                sheetIndex++
            }
            
            return ExcelFileStructure(
                fileName = "import.xlsx",
                sheets = sheets,
                totalRows = sheets.sumOf { it.rowCount }
            )
        } finally {
            pkg.close()
        }
    }
    
    private fun getSheetName(reader: XSSFReader, index: Int): String {
        // 实现获取工作表名称的逻辑
        return "Sheet${index + 1}"
    }
}

/**
 * SAX处理器，用于解析Excel行数据
 */
private class SheetHandler(
    private val sst: SharedStringsTable,
    private val styles: StylesTable,
    private val onRowRead: (Int, Map<String, Any?>) -> Unit
) : org.xml.sax.helpers.DefaultHandler() {
    // 实现SAX解析逻辑
    private var currentRow = -1
    private var currentCol = -1
    private val rowData = mutableMapOf<String, Any?>()
    private val headers = mutableListOf<String>()
    
    override fun startElement(uri: String?, localName: String?, qName: String?, attributes: org.xml.sax.Attributes?) {
        when (qName) {
            "row" -> {
                currentRow++
                rowData.clear()
            }
            "c" -> {
                // 解析单元格
                currentCol++
            }
        }
    }
    
    override fun endElement(uri: String?, localName: String?, qName: String?) {
        when (qName) {
            "row" -> {
                if (currentRow == 0) {
                    // 第一行作为表头
                    headers.addAll(rowData.values.map { it.toString() })
                } else {
                    // 数据行
                    val dataMap = mutableMapOf<String, Any?>()
                    headers.forEachIndexed { index, header ->
                        dataMap[header] = rowData[index.toString()]
                    }
                    onRowRead(currentRow, dataMap)
                }
            }
        }
    }
}
```

#### 4.1.2 创建简单的XLSX读取器作为降级方案
创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/SimpleXlsxReader.kt`

```kotlin
package com.ccxiaoji.app.data.excel

import java.io.InputStream
import java.util.zip.ZipInputStream
import javax.inject.Inject

/**
 * 简单的XLSX读取器，作为POI失败时的降级方案
 * 仅支持基本的文本和数字读取
 */
class SimpleXlsxReader @Inject constructor() {
    
    suspend fun readSimpleXlsx(
        inputStream: InputStream,
        onRowRead: (rowIndex: Int, row: List<String>) -> Unit
    ) {
        val zip = ZipInputStream(inputStream)
        var entry = zip.nextEntry
        
        while (entry != null) {
            if (entry.name == "xl/worksheets/sheet1.xml") {
                // 解析第一个工作表
                parseSheetXml(zip, onRowRead)
                break
            }
            entry = zip.nextEntry
        }
        
        zip.close()
    }
    
    private fun parseSheetXml(
        inputStream: InputStream,
        onRowRead: (Int, List<String>) -> Unit
    ) {
        // 简单的XML解析实现
        // 这里使用Android内置的XmlPullParser
        val parser = android.util.Xml.newPullParser()
        parser.setInput(inputStream, "UTF-8")
        
        var eventType = parser.eventType
        var currentRow = -1
        val rowData = mutableListOf<String>()
        
        while (eventType != org.xmlpull.v1.XmlPullParser.END_DOCUMENT) {
            when (eventType) {
                org.xmlpull.v1.XmlPullParser.START_TAG -> {
                    when (parser.name) {
                        "row" -> {
                            currentRow++
                            rowData.clear()
                        }
                        "v" -> {
                            // 读取单元格值
                            parser.next()
                            if (parser.eventType == org.xmlpull.v1.XmlPullParser.TEXT) {
                                rowData.add(parser.text)
                            }
                        }
                    }
                }
                org.xmlpull.v1.XmlPullParser.END_TAG -> {
                    if (parser.name == "row" && rowData.isNotEmpty()) {
                        onRowRead(currentRow, rowData)
                    }
                }
            }
            eventType = parser.next()
        }
    }
}
```

### 第二阶段：统一数据格式（Day 3）

#### 4.2.1 创建统一的列映射配置
创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/mapping/ExcelColumnMappings.kt`

```kotlin
package com.ccxiaoji.app.data.excel.mapping

/**
 * Excel列映射配置
 * 统一管理导入导出的列名，确保一致性
 */
object ExcelColumnMappings {
    
    // 待办任务映射
    val todoMappings = listOf(
        ColumnMapping("id", "ID", DataType.LONG, isIdField = true),
        ColumnMapping("title", "标题", DataType.STRING, required = true),
        ColumnMapping("description", "描述", DataType.STRING), // 统一为"描述"
        ColumnMapping("priority", "优先级", DataType.PRIORITY),
        ColumnMapping("dueDate", "截止日期", DataType.DATE),
        ColumnMapping("isCompleted", "完成状态", DataType.BOOLEAN),
        ColumnMapping("tags", "标签", DataType.STRING_LIST), // 新增标签字段
        ColumnMapping("createdAt", "创建时间", DataType.DATETIME),
        ColumnMapping("completedAt", "完成时间", DataType.DATETIME)
    )
    
    // 习惯记录映射
    val habitMappings = listOf(
        ColumnMapping("id", "ID", DataType.LONG, isIdField = true),
        ColumnMapping("name", "习惯名称", DataType.STRING, required = true),
        ColumnMapping("targetCount", "目标次数", DataType.INTEGER), // 统一为"目标次数"
        ColumnMapping("period", "周期", DataType.PERIOD),
        ColumnMapping("createdAt", "创建时间", DataType.DATETIME), // 统一为"创建时间"
        ColumnMapping("currentStreak", "当前连续天数", DataType.INTEGER),
        ColumnMapping("longestStreak", "历史最长连续", DataType.INTEGER),
        ColumnMapping("totalCompletions", "总完成次数", DataType.INTEGER)
    )
    
    // 交易记录映射
    val transactionMappings = listOf(
        ColumnMapping("id", "ID", DataType.LONG, isIdField = true),
        ColumnMapping("date", "日期", DataType.DATE, required = true),
        ColumnMapping("type", "类型", DataType.TRANSACTION_TYPE, required = true),
        ColumnMapping("amount", "金额", DataType.DECIMAL, required = true),
        ColumnMapping("accountName", "账户", DataType.STRING, required = true),
        ColumnMapping("categoryName", "分类", DataType.STRING),
        ColumnMapping("note", "备注", DataType.STRING),
        ColumnMapping("tags", "标签", DataType.STRING_LIST)
    )
    
    // 账户映射
    val accountMappings = listOf(
        ColumnMapping("id", "ID", DataType.LONG, isIdField = true),
        ColumnMapping("name", "账户名称", DataType.STRING, required = true),
        ColumnMapping("type", "账户类型", DataType.ACCOUNT_TYPE, required = true),
        ColumnMapping("balance", "当前余额", DataType.DECIMAL),
        ColumnMapping("initialBalance", "初始余额", DataType.DECIMAL),
        ColumnMapping("currency", "货币", DataType.STRING, defaultValue = "CNY"),
        ColumnMapping("isActive", "是否启用", DataType.BOOLEAN, defaultValue = true)
    )
    
    // 分类映射
    val categoryMappings = listOf(
        ColumnMapping("id", "ID", DataType.LONG, isIdField = true),
        ColumnMapping("name", "分类名称", DataType.STRING, required = true),
        ColumnMapping("type", "分类类型", DataType.CATEGORY_TYPE, required = true),
        ColumnMapping("parentName", "父分类", DataType.STRING),
        ColumnMapping("icon", "图标", DataType.STRING),
        ColumnMapping("color", "颜色", DataType.STRING)
    )
    
    /**
     * 根据模块获取映射
     */
    fun getMappingsForModule(module: ExcelDataModule): List<ColumnMapping> {
        return when (module) {
            ExcelDataModule.TASKS -> todoMappings
            ExcelDataModule.HABITS -> habitMappings
            ExcelDataModule.TRANSACTIONS -> transactionMappings
            ExcelDataModule.ACCOUNTS -> accountMappings
            ExcelDataModule.CATEGORIES -> categoryMappings
        }
    }
}

/**
 * 列映射定义
 */
data class ColumnMapping(
    val dbField: String,        // 数据库字段名
    val excelHeader: String,    // Excel列标题
    val dataType: DataType,     // 数据类型
    val required: Boolean = false,      // 是否必填
    val defaultValue: Any? = null,      // 默认值
    val isIdField: Boolean = false,     // 是否是ID字段
    val dateFormat: String? = null      // 日期格式
)

/**
 * 数据类型枚举
 */
enum class DataType {
    STRING,
    INTEGER,
    LONG,
    DECIMAL,
    BOOLEAN,
    DATE,
    DATETIME,
    STRING_LIST,        // 逗号分隔的字符串列表
    PRIORITY,           // 优先级（高/中/低）
    PERIOD,             // 周期（每日/每周/每月）
    TRANSACTION_TYPE,   // 交易类型（收入/支出/转账）
    ACCOUNT_TYPE,       // 账户类型
    CATEGORY_TYPE       // 分类类型
}
```

#### 4.2.2 修改导出功能使用统一列名
修改文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/ExcelManager.kt`

```kotlin
// 在ExcelManager.kt中修改导出方法

private suspend fun exportTodos(workbook: XSSFWorkbook): Int {
    val todos = todoApi.getAllTasks().first()
    if (todos.isEmpty()) return 0
    
    val sheet = workbook.createSheet("待办任务")
    val headerRow = sheet.createRow(0)
    
    // 使用统一的列映射创建表头
    val mappings = ExcelColumnMappings.todoMappings
    mappings.forEachIndexed { index, mapping ->
        val cell = headerRow.createCell(index)
        cell.setCellValue(mapping.excelHeader)
        cell.cellStyle = headerStyle
    }
    
    // 导出数据
    todos.forEachIndexed { rowIndex, todo ->
        val row = sheet.createRow(rowIndex + 1)
        
        mappings.forEachIndexed { colIndex, mapping ->
            val cell = row.createCell(colIndex)
            
            when (mapping.dbField) {
                "id" -> cell.setCellValue(todo.id.toDouble())
                "title" -> cell.setCellValue(todo.title)
                "description" -> cell.setCellValue(todo.description ?: "")
                "priority" -> cell.setCellValue(todo.priorityLevel.displayName)
                "dueDate" -> todo.dueDate?.let {
                    cell.setCellValue(dateFormat.format(Date(it)))
                }
                "isCompleted" -> cell.setCellValue(if (todo.isCompleted) "是" else "否")
                "tags" -> cell.setCellValue(todo.tags.joinToString(","))
                "createdAt" -> cell.setCellValue(
                    timestampAdapter.toLocalDateTimeString(todo.createdAt)
                )
                "completedAt" -> todo.completedDate?.let {
                    cell.setCellValue(timestampAdapter.toLocalDateTimeString(it))
                }
            }
        }
    }
    
    // 设置列宽（使用固定宽度，避免autoSizeColumn）
    mappings.forEachIndexed { index, mapping ->
        sheet.setColumnWidth(index, when (mapping.dataType) {
            DataType.STRING, DataType.STRING_LIST -> 256 * 20
            DataType.DATE, DataType.DATETIME -> 256 * 15
            DataType.INTEGER, DataType.DECIMAL -> 256 * 10
            else -> 256 * 12
        })
    }
    
    return todos.size
}

// 类似地修改其他模块的导出方法...
```

### 第三阶段：实现高性能导入（Day 4-5）

#### 4.3.1 创建增强的批量导入处理器
创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/EnhancedBatchImportProcessor.kt`

```kotlin
package com.ccxiaoji.app.data.excel

import com.ccxiaoji.app.data.importer.ImportExportError
import com.ccxiaoji.feature.ledger.data.local.dao.*
import com.ccxiaoji.feature.todo.data.local.dao.TaskDao
import com.ccxiaoji.feature.habit.data.local.dao.HabitDao
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Singleton

/**
 * 增强的批量导入处理器
 * 使用Room的批量API提升性能
 */
@Singleton
class EnhancedBatchImportProcessor @Inject constructor(
    private val transactionDao: TransactionDao,
    private val categoryDao: CategoryDao,
    private val accountDao: AccountDao,
    private val taskDao: TaskDao,
    private val habitDao: HabitDao
) {
    companion object {
        const val BATCH_SIZE = 200 // 每批处理200条
        const val MAX_RETRY_COUNT = 3 // 最大重试次数
    }
    
    /**
     * 批量导入交易记录
     */
    suspend fun importTransactions(
        transactions: List<TransactionEntity>,
        onProgress: (current: Int, total: Int) -> Unit,
        onError: (row: Int, error: String) -> Unit
    ): BatchImportResult = withContext(Dispatchers.IO) {
        val results = mutableListOf<RowImportResult>()
        var successCount = 0
        var failedCount = 0
        
        // 分批处理
        transactions.chunked(BATCH_SIZE).forEachIndexed { batchIndex, batch ->
            val batchStartRow = batchIndex * BATCH_SIZE
            
            try {
                // 尝试批量插入
                transactionDao.insertTransactions(batch)
                
                // 批量成功，记录所有行为成功
                batch.forEachIndexed { index, _ ->
                    val rowNum = batchStartRow + index + 2 // +2因为Excel从1开始且有表头
                    results.add(RowImportResult.success(rowNum))
                    successCount++
                }
                
            } catch (e: Exception) {
                // 批量失败，降级为单条插入以定位问题
                batch.forEachIndexed { index, transaction ->
                    val rowNum = batchStartRow + index + 2
                    
                    val result = insertSingleTransaction(transaction, rowNum)
                    results.add(result)
                    
                    if (result.success) {
                        successCount++
                    } else {
                        failedCount++
                        onError(rowNum, result.error ?: "未知错误")
                    }
                }
            }
            
            // 更新进度
            val processed = minOf((batchIndex + 1) * BATCH_SIZE, transactions.size)
            onProgress(processed, transactions.size)
        }
        
        BatchImportResult(
            totalRows = transactions.size,
            successRows = successCount,
            failedRows = failedCount,
            rowResults = results
        )
    }
    
    /**
     * 单条插入交易记录（用于错误恢复）
     */
    private suspend fun insertSingleTransaction(
        transaction: TransactionEntity,
        rowNum: Int
    ): RowImportResult {
        return try {
            // 验证外键约束
            if (!accountDao.exists(transaction.accountId)) {
                return RowImportResult.error(rowNum, "账户不存在")
            }
            
            if (transaction.categoryId != null && !categoryDao.exists(transaction.categoryId)) {
                return RowImportResult.error(rowNum, "分类不存在")
            }
            
            // 插入记录
            transactionDao.insertTransaction(transaction)
            RowImportResult.success(rowNum)
            
        } catch (e: Exception) {
            RowImportResult.error(rowNum, e.message ?: "插入失败")
        }
    }
    
    /**
     * 批量导入任务
     */
    suspend fun importTasks(
        tasks: List<TaskEntity>,
        onProgress: (current: Int, total: Int) -> Unit
    ): BatchImportResult = withContext(Dispatchers.IO) {
        val results = mutableListOf<RowImportResult>()
        
        tasks.chunked(BATCH_SIZE).forEachIndexed { batchIndex, batch ->
            try {
                // Room没有提供批量插入任务的方法，需要逐条插入
                // 但可以在一个事务中完成
                taskDao.insertTasksInTransaction(batch)
                
                batch.forEachIndexed { index, _ ->
                    val rowNum = batchIndex * BATCH_SIZE + index + 2
                    results.add(RowImportResult.success(rowNum))
                }
            } catch (e: Exception) {
                // 错误处理
                batch.forEachIndexed { index, task ->
                    val rowNum = batchIndex * BATCH_SIZE + index + 2
                    results.add(RowImportResult.error(rowNum, e.message ?: "插入失败"))
                }
            }
            
            val processed = minOf((batchIndex + 1) * BATCH_SIZE, tasks.size)
            onProgress(processed, tasks.size)
        }
        
        BatchImportResult(
            totalRows = tasks.size,
            successRows = results.count { it.success },
            failedRows = results.count { !it.success },
            rowResults = results
        )
    }
    
    /**
     * 批量导入习惯
     */
    suspend fun importHabits(
        habits: List<HabitEntity>,
        onProgress: (current: Int, total: Int) -> Unit
    ): BatchImportResult = withContext(Dispatchers.IO) {
        // 实现类似的批量导入逻辑
        val results = mutableListOf<RowImportResult>()
        
        habits.forEachIndexed { index, habit ->
            try {
                habitDao.insertHabit(habit)
                results.add(RowImportResult.success(index + 2))
            } catch (e: Exception) {
                results.add(RowImportResult.error(index + 2, e.message ?: "插入失败"))
            }
            onProgress(index + 1, habits.size)
        }
        
        BatchImportResult(
            totalRows = habits.size,
            successRows = results.count { it.success },
            failedRows = results.count { !it.success },
            rowResults = results
        )
    }
}

/**
 * 批量导入结果
 */
data class BatchImportResult(
    val totalRows: Int,
    val successRows: Int,
    val failedRows: Int,
    val rowResults: List<RowImportResult>
)

/**
 * 单行导入结果
 */
data class RowImportResult(
    val rowNumber: Int,
    val success: Boolean,
    val error: String? = null
) {
    companion object {
        fun success(rowNumber: Int) = RowImportResult(rowNumber, true)
        fun error(rowNumber: Int, error: String) = RowImportResult(rowNumber, false, error)
    }
}
```

#### 4.3.2 实现流式Excel导入管理器
创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/StreamingExcelImportManager.kt`

```kotlin
package com.ccxiaoji.app.data.excel

import android.content.Context
import android.net.Uri
import com.ccxiaoji.app.data.excel.mapping.ExcelColumnMappings
import com.ccxiaoji.app.data.importer.ImportExportError
import com.ccxiaoji.feature.ledger.data.local.entity.TransactionEntity
import com.ccxiaoji.feature.todo.data.local.entity.TaskEntity
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Singleton

/**
 * 流式Excel导入管理器
 * 优化内存使用，支持大文件导入
 */
@Singleton
class StreamingExcelImportManager @Inject constructor(
    private val context: Context,
    private val safeExcelReader: SafeExcelReader,
    private val batchProcessor: EnhancedBatchImportProcessor,
    private val columnValidator: ColumnMappingValidator,
    private val dataParser: ExcelDataParser,
    private val importValidator: ImportValidator
) {
    private val _importState = MutableStateFlow<ImportState>(ImportState.Idle)
    val importState: StateFlow<ImportState> = _importState
    
    /**
     * 流式导入Excel文件
     */
    suspend fun importExcel(
        uri: Uri,
        options: ExcelImportOptions
    ): ExcelImportResult = withContext(Dispatchers.IO) {
        _importState.value = ImportState.Preparing
        
        val inputStream = context.contentResolver.openInputStream(uri)
            ?: throw ImportExportError.FileNotFound()
            
        val moduleResults = mutableMapOf<ExcelDataModule, ExcelModuleImportResult>()
        val errors = mutableListOf<ExcelImportError>()
        
        try {
            // 分析文件结构
            val structure = safeExcelReader.analyzeExcelStructure(inputStream)
            _importState.value = ImportState.Analyzing(structure)
            
            // 重新打开流进行实际导入
            val dataStream = context.contentResolver.openInputStream(uri)
                ?: throw ImportExportError.FileNotFound()
                
            // 按模块处理每个工作表
            for (sheet in options.selectedSheets) {
                when (sheet.name) {
                    "待办任务" -> {
                        if (ExcelDataModule.TASKS in options.selectedModules) {
                            val result = importTasksFromSheet(dataStream, sheet, options)
                            moduleResults[ExcelDataModule.TASKS] = result
                        }
                    }
                    "习惯记录" -> {
                        if (ExcelDataModule.HABITS in options.selectedModules) {
                            val result = importHabitsFromSheet(dataStream, sheet, options)
                            moduleResults[ExcelDataModule.HABITS] = result
                        }
                    }
                    "交易记录" -> {
                        if (ExcelDataModule.TRANSACTIONS in options.selectedModules) {
                            val result = importTransactionsFromSheet(dataStream, sheet, options)
                            moduleResults[ExcelDataModule.TRANSACTIONS] = result
                        }
                    }
                }
            }
            
            dataStream.close()
            
            // 构建最终结果
            val totalItems = moduleResults.values.sumOf { it.totalItems }
            val importedItems = moduleResults.values.sumOf { it.importedItems }
            val skippedItems = moduleResults.values.sumOf { it.skippedItems }
            
            _importState.value = ImportState.Completed
            
            ExcelImportResult(
                success = errors.isEmpty(),
                totalItems = totalItems,
                importedItems = importedItems,
                skippedItems = skippedItems,
                errors = errors,
                moduleResults = moduleResults
            )
            
        } catch (e: Exception) {
            _importState.value = ImportState.Error(e.message ?: "导入失败")
            throw ImportExportError.ImportFailed(e.message ?: "未知错误")
        } finally {
            inputStream.close()
        }
    }
    
    /**
     * 导入任务数据
     */
    private suspend fun importTasksFromSheet(
        inputStream: InputStream,
        sheet: SheetInfo,
        options: ExcelImportOptions
    ): ExcelModuleImportResult {
        val buffer = mutableListOf<TaskEntity>()
        val errors = mutableListOf<String>()
        var totalRows = 0
        var importedRows = 0
        var skippedRows = 0
        var headers: List<String>? = null
        
        _importState.value = ImportState.Importing(
            module = ExcelDataModule.TASKS,
            current = 0,
            total = sheet.rowCount
        )
        
        safeExcelReader.readExcelStreaming(inputStream, sheet.name) { rowIndex, rowData ->
            totalRows++
            
            if (rowIndex == 0) {
                // 验证表头
                headers = rowData.keys.toList()
                val validation = columnValidator.validateHeaders(
                    headers!!,
                    ExcelColumnMappings.todoMappings
                )
                if (!validation.isValid) {
                    throw ImportExportError.InvalidFormat(validation.errors)
                }
            } else {
                // 解析数据行
                try {
                    val task = dataParser.parseTaskRow(rowData, rowIndex + 1)
                    
                    // 根据合并策略处理
                    when (options.mergeStrategy) {
                        MergeStrategy.SKIP_DUPLICATES -> {
                            if (!isDuplicateTask(task)) {
                                buffer.add(task)
                            } else {
                                skippedRows++
                            }
                        }
                        MergeStrategy.REPLACE_EXISTING -> {
                            buffer.add(task)
                        }
                        MergeStrategy.MERGE_DATA -> {
                            val merged = mergeTask(task)
                            buffer.add(merged)
                        }
                    }
                    
                    // 达到批量大小时处理
                    if (buffer.size >= EnhancedBatchImportProcessor.BATCH_SIZE) {
                        val result = batchProcessor.importTasks(buffer) { current, total ->
                            _importState.update {
                                if (it is ImportState.Importing) {
                                    it.copy(current = current)
                                } else it
                            }
                        }
                        importedRows += result.successRows
                        buffer.clear()
                    }
                    
                } catch (e: Exception) {
                    errors.add("行 ${rowIndex + 1}: ${e.message}")
                }
            }
        }
        
        // 处理剩余数据
        if (buffer.isNotEmpty()) {
            val result = batchProcessor.importTasks(buffer) { current, total ->
                _importState.update {
                    if (it is ImportState.Importing) {
                        it.copy(current = current)
                    } else it
                }
            }
            importedRows += result.successRows
        }
        
        return ExcelModuleImportResult(
            module = ExcelDataModule.TASKS,
            success = errors.isEmpty(),
            totalItems = totalRows - 1, // 减去表头
            importedItems = importedRows,
            skippedItems = skippedRows,
            errors = errors
        )
    }
    
    /**
     * 检查任务是否重复
     */
    private suspend fun isDuplicateTask(task: TaskEntity): Boolean {
        // 实现重复检测逻辑
        // 可以基于标题、创建时间等字段判断
        return false
    }
    
    /**
     * 合并任务数据
     */
    private suspend fun mergeTask(newTask: TaskEntity): TaskEntity {
        // 实现数据合并逻辑
        // 查找已存在的任务并合并字段
        return newTask
    }
    
    // 类似地实现 importHabitsFromSheet 和 importTransactionsFromSheet
}

/**
 * 导入状态
 */
sealed class ImportState {
    object Idle : ImportState()
    object Preparing : ImportState()
    data class Analyzing(val structure: ExcelFileStructure) : ImportState()
    data class Importing(
        val module: ExcelDataModule,
        val current: Int,
        val total: Int
    ) : ImportState()
    object Completed : ImportState()
    data class Error(val message: String) : ImportState()
}
```

### 第四阶段：数据完整性保障（Day 6）

#### 4.4.1 创建数据完整性服务
创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/DataIntegrityService.kt`

```kotlin
package com.ccxiaoji.app.data.excel

import com.ccxiaoji.feature.habit.domain.repository.HabitRepository
import com.ccxiaoji.feature.todo.domain.repository.TaskRepository
import com.ccxiaoji.feature.ledger.domain.repository.AccountRepository
import com.ccxiaoji.feature.ledger.domain.repository.TransactionRepository
import kotlinx.coroutines.flow.first
import javax.inject.Inject
import javax.inject.Singleton

/**
 * 数据完整性服务
 * 负责导入后重建派生数据，确保数据一致性
 */
@Singleton
class DataIntegrityService @Inject constructor(
    private val habitRepository: HabitRepository,
    private val taskRepository: TaskRepository,
    private val accountRepository: AccountRepository,
    private val transactionRepository: TransactionRepository
) {
    
    /**
     * 导入完成后重建所有派生数据
     */
    suspend fun rebuildDerivedData(
        importedModules: Set<ExcelDataModule>,
        onProgress: (String) -> Unit
    ) {
        if (ExcelDataModule.HABITS in importedModules) {
            onProgress("正在重建习惯统计数据...")
            rebuildHabitStatistics()
        }
        
        if (ExcelDataModule.TASKS in importedModules) {
            onProgress("正在更新任务完成状态...")
            updateTaskCompletionStatus()
        }
        
        if (ExcelDataModule.TRANSACTIONS in importedModules) {
            onProgress("正在重新计算账户余额...")
            recalculateAccountBalances()
        }
        
        if (ExcelDataModule.ACCOUNTS in importedModules) {
            onProgress("正在验证账户初始余额...")
            validateInitialBalances()
        }
        
        onProgress("数据完整性检查完成")
    }
    
    /**
     * 重建习惯统计数据
     */
    private suspend fun rebuildHabitStatistics() {
        val habits = habitRepository.getAllHabits().first()
        
        habits.forEach { habit ->
            // 获取该习惯的所有完成记录
            val completions = habitRepository.getHabitCompletions(habit.id).first()
            
            // 计算连续天数
            val currentStreak = calculateCurrentStreak(completions)
            val longestStreak = calculateLongestStreak(completions)
            val totalCompletions = completions.size
            
            // 更新统计数据
            habitRepository.updateHabitStatistics(
                habitId = habit.id,
                currentStreak = currentStreak,
                longestStreak = longestStreak,
                totalCompletions = totalCompletions
            )
        }
    }
    
    /**
     * 计算当前连续天数
     */
    private fun calculateCurrentStreak(completions: List<HabitCompletion>): Int {
        if (completions.isEmpty()) return 0
        
        val sortedDates = completions
            .map { it.completionDate }
            .sortedDescending()
            
        var streak = 1
        var previousDate = sortedDates.first()
        
        for (i in 1 until sortedDates.size) {
            val currentDate = sortedDates[i]
            val daysDiff = previousDate.toEpochDays() - currentDate.toEpochDays()
            
            if (daysDiff == 1L) {
                streak++
                previousDate = currentDate
            } else {
                break
            }
        }
        
        return streak
    }
    
    /**
     * 计算历史最长连续天数
     */
    private fun calculateLongestStreak(completions: List<HabitCompletion>): Int {
        if (completions.isEmpty()) return 0
        
        val sortedDates = completions
            .map { it.completionDate }
            .sorted()
            
        var currentStreak = 1
        var longestStreak = 1
        var previousDate = sortedDates.first()
        
        for (i in 1 until sortedDates.size) {
            val currentDate = sortedDates[i]
            val daysDiff = currentDate.toEpochDays() - previousDate.toEpochDays()
            
            when (daysDiff) {
                0L -> continue // 同一天多次完成
                1L -> {
                    currentStreak++
                    longestStreak = maxOf(longestStreak, currentStreak)
                }
                else -> currentStreak = 1
            }
            
            previousDate = currentDate
        }
        
        return longestStreak
    }
    
    /**
     * 更新任务完成状态
     * 确保标记为已完成的任务有正确的完成时间
     */
    private suspend fun updateTaskCompletionStatus() {
        val tasks = taskRepository.getAllTasks().first()
        
        tasks.forEach { task ->
            if (task.isCompleted && task.completedDate == null) {
                // 如果任务已完成但没有完成时间，使用更新时间作为完成时间
                taskRepository.updateTaskCompletionTime(
                    taskId = task.id,
                    completedAt = task.updatedAt
                )
            }
        }
    }
    
    /**
     * 重新计算所有账户余额
     */
    private suspend fun recalculateAccountBalances() {
        val accounts = accountRepository.getAllAccounts().first()
        
        accounts.forEach { account ->
            val transactions = transactionRepository
                .getTransactionsByAccount(account.id)
                .first()
                
            val calculatedBalance = calculateAccountBalance(
                initialBalance = account.initialBalance,
                transactions = transactions
            )
            
            // 更新账户余额
            accountRepository.updateAccountBalance(
                accountId = account.id,
                balance = calculatedBalance
            )
        }
    }
    
    /**
     * 计算账户余额
     */
    private fun calculateAccountBalance(
        initialBalance: Double,
        transactions: List<Transaction>
    ): Double {
        return transactions.fold(initialBalance) { balance, transaction ->
            when (transaction.type) {
                TransactionType.INCOME -> balance + transaction.amount
                TransactionType.EXPENSE -> balance - transaction.amount
                TransactionType.TRANSFER -> {
                    // 转账需要特殊处理
                    if (transaction.fromAccountId == transaction.accountId) {
                        balance - transaction.amount
                    } else {
                        balance + transaction.amount
                    }
                }
            }
        }
    }
    
    /**
     * 验证初始余额
     * 确保导入的账户有正确的初始余额设置
     */
    private suspend fun validateInitialBalances() {
        val accounts = accountRepository.getAllAccounts().first()
        
        accounts.forEach { account ->
            if (account.initialBalance == 0.0) {
                // 检查是否有"期初余额"类型的交易
                val initialTransaction = transactionRepository
                    .getInitialBalanceTransaction(account.id)
                    .firstOrNull()
                    
                if (initialTransaction != null) {
                    // 使用期初余额交易更新账户初始余额
                    accountRepository.updateInitialBalance(
                        accountId = account.id,
                        initialBalance = initialTransaction.amount
                    )
                }
            }
        }
    }
}
```

#### 4.4.2 创建导入验证器
创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/ImportValidator.kt`

```kotlin
package com.ccxiaoji.app.data.excel

import com.ccxiaoji.feature.ledger.domain.repository.AccountRepository
import com.ccxiaoji.feature.ledger.domain.repository.CategoryRepository
import kotlinx.coroutines.flow.first
import javax.inject.Inject
import javax.inject.Singleton

/**
 * 导入数据验证器
 * 在导入前验证数据的有效性
 */
@Singleton
class ImportValidator @Inject constructor(
    private val accountRepository: AccountRepository,
    private val categoryRepository: CategoryRepository
) {
    
    /**
     * 验证导入数据
     */
    suspend fun validateImportData(
        data: List<Map<String, Any?>>,
        module: ExcelDataModule
    ): ValidationResult {
        val errors = mutableListOf<ValidationError>()
        
        when (module) {
            ExcelDataModule.TRANSACTIONS -> validateTransactions(data, errors)
            ExcelDataModule.TASKS -> validateTasks(data, errors)
            ExcelDataModule.HABITS -> validateHabits(data, errors)
            ExcelDataModule.ACCOUNTS -> validateAccounts(data, errors)
            ExcelDataModule.CATEGORIES -> validateCategories(data, errors)
        }
        
        return ValidationResult(
            isValid = errors.isEmpty(),
            errors = errors,
            warnings = detectWarnings(data, module)
        )
    }
    
    /**
     * 验证交易数据
     */
    private suspend fun validateTransactions(
        data: List<Map<String, Any?>>,
        errors: MutableList<ValidationError>
    ) {
        // 获取现有账户和分类
        val existingAccounts = accountRepository.getAllAccounts()
            .first()
            .map { it.name }
            .toSet()
            
        val existingCategories = categoryRepository.getAllCategories()
            .first()
            .map { it.name }
            .toSet()
        
        data.forEachIndexed { index, row ->
            val rowNum = index + 2 // Excel行号（跳过表头）
            
            // 验证必填字段
            if (row["日期"] == null) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "日期",
                    message = "日期不能为空",
                    severity = ErrorSeverity.ERROR
                ))
            }
            
            if (row["金额"] == null) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "金额",
                    message = "金额不能为空",
                    severity = ErrorSeverity.ERROR
                ))
            } else {
                // 验证金额格式
                val amount = row["金额"].toString().toDoubleOrNull()
                if (amount == null || amount <= 0) {
                    errors.add(ValidationError(
                        row = rowNum,
                        column = "金额",
                        message = "金额必须是大于0的数字",
                        severity = ErrorSeverity.ERROR
                    ))
                }
            }
            
            // 验证账户是否存在
            val accountName = row["账户"]?.toString()
            if (accountName != null && accountName !in existingAccounts) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "账户",
                    message = "账户'$accountName'不存在，请先创建该账户",
                    severity = ErrorSeverity.WARNING
                ))
            }
            
            // 验证分类是否存在
            val categoryName = row["分类"]?.toString()
            if (categoryName != null && categoryName !in existingCategories) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "分类",
                    message = "分类'$categoryName'不存在，将自动创建",
                    severity = ErrorSeverity.INFO
                ))
            }
            
            // 验证交易类型
            val type = row["类型"]?.toString()
            if (type != null && type !in listOf("收入", "支出", "转账")) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "类型",
                    message = "类型必须是：收入、支出或转账",
                    severity = ErrorSeverity.ERROR
                ))
            }
        }
    }
    
    /**
     * 验证任务数据
     */
    private fun validateTasks(
        data: List<Map<String, Any?>>,
        errors: MutableList<ValidationError>
    ) {
        data.forEachIndexed { index, row ->
            val rowNum = index + 2
            
            // 验证标题
            if (row["标题"]?.toString().isNullOrBlank()) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "标题",
                    message = "任务标题不能为空",
                    severity = ErrorSeverity.ERROR
                ))
            }
            
            // 验证优先级
            val priority = row["优先级"]?.toString()
            if (priority != null && priority !in listOf("高", "中", "低")) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "优先级",
                    message = "优先级必须是：高、中或低",
                    severity = ErrorSeverity.WARNING
                ))
            }
            
            // 验证完成状态
            val completed = row["完成状态"]?.toString()
            if (completed != null && completed !in listOf("是", "否")) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "完成状态",
                    message = "完成状态必须是：是或否",
                    severity = ErrorSeverity.WARNING
                ))
            }
        }
    }
    
    /**
     * 验证习惯数据
     */
    private fun validateHabits(
        data: List<Map<String, Any?>>,
        errors: MutableList<ValidationError>
    ) {
        data.forEachIndexed { index, row ->
            val rowNum = index + 2
            
            // 验证习惯名称
            if (row["习惯名称"]?.toString().isNullOrBlank()) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "习惯名称",
                    message = "习惯名称不能为空",
                    severity = ErrorSeverity.ERROR
                ))
            }
            
            // 验证目标次数
            val targetCount = row["目标次数"]?.toString()?.toIntOrNull()
            if (targetCount != null && targetCount <= 0) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "目标次数",
                    message = "目标次数必须大于0",
                    severity = ErrorSeverity.WARNING
                ))
            }
            
            // 验证周期
            val period = row["周期"]?.toString()
            if (period != null && period !in listOf("每日", "每周", "每月")) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "周期",
                    message = "周期必须是：每日、每周或每月",
                    severity = ErrorSeverity.ERROR
                ))
            }
        }
    }
    
    /**
     * 验证账户数据
     */
    private fun validateAccounts(
        data: List<Map<String, Any?>>,
        errors: MutableList<ValidationError>
    ) {
        val accountNames = mutableSetOf<String>()
        
        data.forEachIndexed { index, row ->
            val rowNum = index + 2
            
            // 验证账户名称
            val name = row["账户名称"]?.toString()
            if (name.isNullOrBlank()) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "账户名称",
                    message = "账户名称不能为空",
                    severity = ErrorSeverity.ERROR
                ))
            } else if (name in accountNames) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "账户名称",
                    message = "账户名称'$name'重复",
                    severity = ErrorSeverity.ERROR
                ))
            } else {
                accountNames.add(name)
            }
            
            // 验证账户类型
            val type = row["账户类型"]?.toString()
            if (type != null && type !in listOf("现金", "银行卡", "信用卡", "支付宝", "微信")) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "账户类型",
                    message = "不支持的账户类型：$type",
                    severity = ErrorSeverity.WARNING
                ))
            }
        }
    }
    
    /**
     * 验证分类数据
     */
    private fun validateCategories(
        data: List<Map<String, Any?>>,
        errors: MutableList<ValidationError>
    ) {
        val categoryNames = mutableSetOf<String>()
        
        data.forEachIndexed { index, row ->
            val rowNum = index + 2
            
            // 验证分类名称
            val name = row["分类名称"]?.toString()
            if (name.isNullOrBlank()) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "分类名称",
                    message = "分类名称不能为空",
                    severity = ErrorSeverity.ERROR
                ))
            } else if (name in categoryNames) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "分类名称",
                    message = "分类名称'$name'重复",
                    severity = ErrorSeverity.WARNING
                ))
            } else {
                categoryNames.add(name)
            }
            
            // 验证分类类型
            val type = row["分类类型"]?.toString()
            if (type != null && type !in listOf("收入", "支出")) {
                errors.add(ValidationError(
                    row = rowNum,
                    column = "分类类型",
                    message = "分类类型必须是：收入或支出",
                    severity = ErrorSeverity.ERROR
                ))
            }
        }
    }
    
    /**
     * 检测警告信息
     */
    private fun detectWarnings(
        data: List<Map<String, Any?>>,
        module: ExcelDataModule
    ): List<ValidationWarning> {
        val warnings = mutableListOf<ValidationWarning>()
        
        // 检测大数据量警告
        if (data.size > 1000) {
            warnings.add(ValidationWarning(
                message = "数据量较大（${data.size}条），导入可能需要较长时间",
                type = WarningType.PERFORMANCE
            ))
        }
        
        // 检测数据完整性警告
        when (module) {
            ExcelDataModule.HABITS -> {
                val hasStatistics = data.any { row ->
                    row["当前连续天数"] != null || 
                    row["历史最长连续"] != null ||
                    row["总完成次数"] != null
                }
                if (hasStatistics) {
                    warnings.add(ValidationWarning(
                        message = "习惯统计数据将在导入后重新计算",
                        type = WarningType.DATA_LOSS
                    ))
                }
            }
            ExcelDataModule.TRANSACTIONS -> {
                val hasInitialBalance = data.any { row ->
                    row["类型"]?.toString() == "-" && 
                    row["分类"]?.toString() == "期初余额"
                }
                if (hasInitialBalance) {
                    warnings.add(ValidationWarning(
                        message = "检测到期初余额记录，将自动处理",
                        type = WarningType.INFO
                    ))
                }
            }
            else -> {}
        }
        
        return warnings
    }
}

/**
 * 验证结果
 */
data class ValidationResult(
    val isValid: Boolean,
    val errors: List<ValidationError>,
    val warnings: List<ValidationWarning> = emptyList()
)

/**
 * 验证错误
 */
data class ValidationError(
    val row: Int,
    val column: String,
    val message: String,
    val severity: ErrorSeverity
)

/**
 * 验证警告
 */
data class ValidationWarning(
    val message: String,
    val type: WarningType
)

/**
 * 错误严重程度
 */
enum class ErrorSeverity {
    INFO,      // 信息提示
    WARNING,   // 警告（可以继续）
    ERROR      // 错误（必须修复）
}

/**
 * 警告类型
 */
enum class WarningType {
    PERFORMANCE,  // 性能相关
    DATA_LOSS,    // 数据丢失
    INFO          // 一般信息
}
```

### 第五阶段：用户体验优化（Day 7）

#### 4.5.1 创建导入错误对话框
创建文件：`app/src/main/java/com/ccxiaoji/app/presentation/ui/components/ImportErrorDialog.kt`

```kotlin
package com.ccxiaoji.app.presentation.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Error
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.ccxiaoji.app.data.excel.RowImportResult
import com.ccxiaoji.app.data.excel.ValidationError
import com.ccxiaoji.app.data.excel.ErrorSeverity

/**
 * 导入错误详情对话框
 */
@Composable
fun ImportErrorDialog(
    errors: List<RowImportResult>,
    validationErrors: List<ValidationError> = emptyList(),
    onDismiss: () -> Unit,
    onExportErrors: () -> Unit,
    onRetryFailed: () -> Unit
) {
    val failedRows = errors.filter { !it.success }
    val successRows = errors.filter { it.success }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = if (failedRows.isEmpty()) Icons.Default.CheckCircle 
                                 else Icons.Default.Warning,
                    contentDescription = null,
                    tint = if (failedRows.isEmpty()) Color.Green else Color.Orange
                )
                Text(
                    text = if (failedRows.isEmpty()) "导入成功" else "导入完成（部分失败）",
                    style = MaterialTheme.typography.headlineSmall
                )
            }
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // 统计信息
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.surfaceVariant
                    )
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text("总计", style = MaterialTheme.typography.bodyMedium)
                            Text(
                                "${errors.size} 条",
                                style = MaterialTheme.typography.bodyMedium,
                                fontWeight = FontWeight.Bold
                            )
                        }
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text("成功", color = Color.Green)
                            Text(
                                "${successRows.size} 条",
                                color = Color.Green,
                                fontWeight = FontWeight.Bold
                            )
                        }
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text("失败", color = Color.Red)
                            Text(
                                "${failedRows.size} 条",
                                color = Color.Red,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
                }
                
                // 验证错误（如果有）
                if (validationErrors.isNotEmpty()) {
                    Text(
                        "数据验证错误",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    
                    LazyColumn(
                        modifier = Modifier
                            .fillMaxWidth()
                            .heightIn(max = 200.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        items(validationErrors.take(10)) { error ->
                            ValidationErrorCard(error)
                        }
                        
                        if (validationErrors.size > 10) {
                            item {
                                Text(
                                    "...还有 ${validationErrors.size - 10} 个错误",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    }
                }
                
                // 导入错误（如果有）
                if (failedRows.isNotEmpty()) {
                    Text(
                        "导入失败详情",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    
                    LazyColumn(
                        modifier = Modifier
                            .fillMaxWidth()
                            .heightIn(max = 200.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        items(failedRows.take(10)) { result ->
                            ImportErrorCard(result)
                        }
                        
                        if (failedRows.size > 10) {
                            item {
                                Text(
                                    "...还有 ${failedRows.size - 10} 个错误",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    }
                }
            }
        },
        confirmButton = {
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                if (failedRows.isNotEmpty()) {
                    TextButton(onClick = onRetryFailed) {
                        Text("重试失败项")
                    }
                    TextButton(onClick = onExportErrors) {
                        Text("导出错误日志")
                    }
                }
                TextButton(onClick = onDismiss) {
                    Text("确定")
                }
            }
        }
    )
}

/**
 * 验证错误卡片
 */
@Composable
private fun ValidationErrorCard(error: ValidationError) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = when (error.severity) {
                ErrorSeverity.ERROR -> Color.Red.copy(alpha = 0.1f)
                ErrorSeverity.WARNING -> Color.Yellow.copy(alpha = 0.1f)
                ErrorSeverity.INFO -> Color.Blue.copy(alpha = 0.1f)
            }
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalAlignment = Alignment.Top
        ) {
            Icon(
                imageVector = when (error.severity) {
                    ErrorSeverity.ERROR -> Icons.Default.Error
                    ErrorSeverity.WARNING -> Icons.Default.Warning
                    ErrorSeverity.INFO -> Icons.Default.Info
                },
                contentDescription = null,
                tint = when (error.severity) {
                    ErrorSeverity.ERROR -> Color.Red
                    ErrorSeverity.WARNING -> Color.Yellow.darken(0.3f)
                    ErrorSeverity.INFO -> Color.Blue
                },
                modifier = Modifier.size(20.dp)
            )
            
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = "第 ${error.row} 行，${error.column}列",
                    style = MaterialTheme.typography.labelMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = error.message,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

/**
 * 导入错误卡片
 */
@Composable
private fun ImportErrorCard(result: RowImportResult) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.errorContainer.copy(alpha = 0.3f)
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            Text(
                text = "第 ${result.rowNumber} 行",
                style = MaterialTheme.typography.labelMedium,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = result.error ?: "未知错误",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.error
            )
        }
    }
}
```

#### 4.5.2 创建导入预览界面
创建文件：`app/src/main/java/com/ccxiaoji/app/presentation/ui/screens/ImportPreviewScreen.kt`

```kotlin
package com.ccxiaoji.app.presentation.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.ccxiaoji.app.data.excel.*

/**
 * Excel导入预览界面
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ImportPreviewScreen(
    fileStructure: ExcelFileStructure,
    onProceed: (ExcelImportOptions) -> Unit,
    onCancel: () -> Unit,
    onValidate: () -> Unit
) {
    var selectedSheets by remember { 
        mutableStateOf(fileStructure.sheets.toSet()) 
    }
    var selectedModules by remember { 
        mutableStateOf(ExcelDataModule.values().toSet()) 
    }
    var mergeStrategy by remember { 
        mutableStateOf(MergeStrategy.SKIP_DUPLICATES) 
    }
    var showAdvancedOptions by remember { mutableStateOf(false) }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("导入预览") },
                navigationIcon = {
                    IconButton(onClick = onCancel) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "返回")
                    }
                },
                actions = {
                    TextButton(onClick = onValidate) {
                        Text("验证数据")
                    }
                }
            )
        },
        bottomBar = {
            Surface(
                modifier = Modifier.fillMaxWidth(),
                tonalElevation = 3.dp
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalArrangement = Arrangement.End,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    TextButton(onClick = onCancel) {
                        Text("取消")
                    }
                    Spacer(modifier = Modifier.width(8.dp))
                    Button(
                        onClick = {
                            onProceed(ExcelImportOptions(
                                selectedModules = selectedModules,
                                selectedSheets = selectedSheets,
                                mergeStrategy = mergeStrategy
                            ))
                        },
                        enabled = selectedSheets.isNotEmpty() && selectedModules.isNotEmpty()
                    ) {
                        Icon(Icons.Default.Upload, contentDescription = null)
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("开始导入")
                    }
                }
            }
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // 文件信息卡片
            item {
                FileInfoCard(fileStructure)
            }
            
            // 工作表选择
            item {
                SheetSelectionCard(
                    sheets = fileStructure.sheets,
                    selectedSheets = selectedSheets,
                    onSelectionChange = { selectedSheets = it }
                )
            }
            
            // 模块选择
            item {
                ModuleSelectionCard(
                    selectedModules = selectedModules,
                    onSelectionChange = { selectedModules = it }
                )
            }
            
            // 数据预览
            if (fileStructure.preview.isNotEmpty()) {
                item {
                    DataPreviewCard(
                        preview = fileStructure.preview,
                        selectedSheet = selectedSheets.firstOrNull()
                    )
                }
            }
            
            // 高级选项
            item {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    onClick = { showAdvancedOptions = !showAdvancedOptions }
                ) {
                    Column {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                "高级选项",
                                style = MaterialTheme.typography.titleMedium
                            )
                            Icon(
                                imageVector = if (showAdvancedOptions) 
                                    Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                                contentDescription = null
                            )
                        }
                        
                        if (showAdvancedOptions) {
                            Divider()
                            Column(
                                modifier = Modifier.padding(16.dp),
                                verticalArrangement = Arrangement.spacedBy(16.dp)
                            ) {
                                // 合并策略
                                MergeStrategySelector(
                                    selected = mergeStrategy,
                                    onSelectionChange = { mergeStrategy = it }
                                )
                                
                                // 其他高级选项
                                Row(
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Checkbox(
                                        checked = false,
                                        onCheckedChange = { }
                                    )
                                    Text(
                                        "忽略余额验证错误",
                                        modifier = Modifier.padding(start = 8.dp)
                                    )
                                }
                                
                                Row(
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Checkbox(
                                        checked = true,
                                        onCheckedChange = { }
                                    )
                                    Text(
                                        "导入后重建统计数据",
                                        modifier = Modifier.padding(start = 8.dp)
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * 文件信息卡片
 */
@Composable
private fun FileInfoCard(fileStructure: ExcelFileStructure) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                "文件信息",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("文件名", color = MaterialTheme.colorScheme.onSurfaceVariant)
                Text(fileStructure.fileName)
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("工作表数", color = MaterialTheme.colorScheme.onSurfaceVariant)
                Text("${fileStructure.sheets.size} 个")
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("总行数", color = MaterialTheme.colorScheme.onSurfaceVariant)
                Text("${fileStructure.totalRows} 行")
            }
            
            if (fileStructure.fileSize > 0) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text("文件大小", color = MaterialTheme.colorScheme.onSurfaceVariant)
                    Text(formatFileSize(fileStructure.fileSize))
                }
            }
        }
    }
}

/**
 * 工作表选择卡片
 */
@Composable
private fun SheetSelectionCard(
    sheets: List<SheetInfo>,
    selectedSheets: Set<SheetInfo>,
    onSelectionChange: (Set<SheetInfo>) -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    "选择工作表",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                
                TextButton(
                    onClick = {
                        onSelectionChange(
                            if (selectedSheets.size == sheets.size) emptySet()
                            else sheets.toSet()
                        )
                    }
                ) {
                    Text(
                        if (selectedSheets.size == sheets.size) "取消全选" else "全选"
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            sheets.forEach { sheet ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 4.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = sheet in selectedSheets,
                        onCheckedChange = { checked ->
                            onSelectionChange(
                                if (checked) selectedSheets + sheet
                                else selectedSheets - sheet
                            )
                        }
                    )
                    
                    Column(
                        modifier = Modifier
                            .weight(1f)
                            .padding(start = 8.dp)
                    ) {
                        Text(
                            sheet.name,
                            style = MaterialTheme.typography.bodyLarge
                        )
                        Text(
                            "${sheet.rowCount} 行",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    
                    // 显示工作表类型图标
                    Icon(
                        imageVector = getSheetIcon(sheet.name),
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary
                    )
                }
            }
        }
    }
}

/**
 * 模块选择卡片
 */
@Composable
private fun ModuleSelectionCard(
    selectedModules: Set<ExcelDataModule>,
    onSelectionChange: (Set<ExcelDataModule>) -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                "导入模块",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            ExcelDataModule.values().forEach { module ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 4.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = module in selectedModules,
                        onCheckedChange = { checked ->
                            onSelectionChange(
                                if (checked) selectedModules + module
                                else selectedModules - module
                            )
                        }
                    )
                    
                    Icon(
                        imageVector = getModuleIcon(module),
                        contentDescription = null,
                        modifier = Modifier.padding(horizontal = 8.dp),
                        tint = MaterialTheme.colorScheme.primary
                    )
                    
                    Text(
                        getModuleName(module),
                        modifier = Modifier.weight(1f)
                    )
                }
            }
        }
    }
}

/**
 * 数据预览卡片
 */
@Composable
private fun DataPreviewCard(
    preview: List<Map<String, Any?>>,
    selectedSheet: SheetInfo?
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                "数据预览${selectedSheet?.let { " - ${it.name}" } ?: ""}",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            if (preview.isEmpty()) {
                Text(
                    "暂无预览数据",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            } else {
                // 显示前5行数据
                preview.take(5).forEachIndexed { index, row ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 4.dp),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.surfaceVariant
                        )
                    ) {
                        Column(
                            modifier = Modifier.padding(12.dp)
                        ) {
                            Text(
                                "第 ${index + 2} 行",
                                style = MaterialTheme.typography.labelSmall,
                                fontWeight = FontWeight.Bold
                            )
                            
                            Spacer(modifier = Modifier.height(4.dp))
                            
                            // 显示前3个字段
                            row.entries.take(3).forEach { (key, value) ->
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                                ) {
                                    Text(
                                        "$key:",
                                        style = MaterialTheme.typography.bodySmall,
                                        color = MaterialTheme.colorScheme.onSurfaceVariant
                                    )
                                    Text(
                                        value?.toString() ?: "(空)",
                                        style = MaterialTheme.typography.bodySmall
                                    )
                                }
                            }
                            
                            if (row.size > 3) {
                                Text(
                                    "...还有 ${row.size - 3} 个字段",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    }
                }
                
                if (preview.size > 5) {
                    Text(
                        "...还有 ${preview.size - 5} 行数据",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.padding(top = 8.dp)
                    )
                }
            }
        }
    }
}

/**
 * 合并策略选择器
 */
@Composable
private fun MergeStrategySelector(
    selected: MergeStrategy,
    onSelectionChange: (MergeStrategy) -> Unit
) {
    Column {
        Text(
            "重复数据处理策略",
            style = MaterialTheme.typography.titleSmall,
            fontWeight = FontWeight.Bold
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        MergeStrategy.values().forEach { strategy ->
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 4.dp),
                verticalAlignment = Alignment.Top
            ) {
                RadioButton(
                    selected = strategy == selected,
                    onClick = { onSelectionChange(strategy) }
                )
                
                Column(
                    modifier = Modifier
                        .weight(1f)
                        .padding(start = 8.dp)
                ) {
                    Text(
                        getMergeStrategyName(strategy),
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        getMergeStrategyDescription(strategy),
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}

// 辅助函数
private fun formatFileSize(bytes: Long): String {
    return when {
        bytes < 1024 -> "$bytes B"
        bytes < 1024 * 1024 -> "${bytes / 1024} KB"
        else -> "${bytes / (1024 * 1024)} MB"
    }
}

private fun getSheetIcon(sheetName: String): ImageVector {
    return when (sheetName) {
        "待办任务" -> Icons.Default.Task
        "习惯记录" -> Icons.Default.Timeline
        "交易记录" -> Icons.Default.AttachMoney
        "账户" -> Icons.Default.AccountBalance
        "分类" -> Icons.Default.Category
        else -> Icons.Default.TableChart
    }
}

private fun getModuleIcon(module: ExcelDataModule): ImageVector {
    return when (module) {
        ExcelDataModule.TASKS -> Icons.Default.Task
        ExcelDataModule.HABITS -> Icons.Default.Timeline
        ExcelDataModule.TRANSACTIONS -> Icons.Default.AttachMoney
        ExcelDataModule.ACCOUNTS -> Icons.Default.AccountBalance
        ExcelDataModule.CATEGORIES -> Icons.Default.Category
    }
}

private fun getModuleName(module: ExcelDataModule): String {
    return when (module) {
        ExcelDataModule.TASKS -> "待办任务"
        ExcelDataModule.HABITS -> "习惯记录"
        ExcelDataModule.TRANSACTIONS -> "交易记录"
        ExcelDataModule.ACCOUNTS -> "账户"
        ExcelDataModule.CATEGORIES -> "分类"
    }
}

private fun getMergeStrategyName(strategy: MergeStrategy): String {
    return when (strategy) {
        MergeStrategy.SKIP_DUPLICATES -> "跳过重复"
        MergeStrategy.REPLACE_EXISTING -> "替换已有"
        MergeStrategy.MERGE_DATA -> "合并数据"
    }
}

private fun getMergeStrategyDescription(strategy: MergeStrategy): String {
    return when (strategy) {
        MergeStrategy.SKIP_DUPLICATES -> "保留现有数据，跳过重复项"
        MergeStrategy.REPLACE_EXISTING -> "用新数据替换已有数据"
        MergeStrategy.MERGE_DATA -> "智能合并，保留更完整的数据"
    }
}
```

## 五、预期效果

### 5.1 技术指标
- **兼容性**: 100%解决Android平台兼容性问题
- **性能**: 1000行数据导入时间 < 3秒
- **内存**: 峰值内存占用 < 30MB
- **成功率**: 导入成功率 > 99%

### 5.2 用户体验
- **格式一致**: 自导出文件可100%成功导入
- **错误定位**: 精确到行列的错误提示
- **进度反馈**: 实时显示导入进度
- **数据完整**: 自动重建统计数据

### 5.3 可维护性
- **模块化设计**: 各组件职责明确
- **统一配置**: 列映射集中管理
- **错误恢复**: 支持批量失败后单条重试
- **扩展性**: 易于添加新的数据模块

## 六、实施建议

1. **分阶段实施**: 严格按照5个阶段顺序执行
2. **充分测试**: 每个阶段完成后进行单元测试和集成测试
3. **性能监控**: 使用Android Studio Profiler监控内存和CPU
4. **用户反馈**: 在内测阶段收集用户反馈并优化

## 七、风险控制

1. **POI兼容性风险**: 准备SimpleXlsxReader作为降级方案
2. **性能风险**: 设置文件大小限制（如10MB）
3. **数据一致性风险**: 导入前备份，支持撤销操作
4. **版本兼容风险**: 锁定POI版本，充分测试后再升级

---
*本文档基于O3模型深度分析生成，请严格按照方案执行，避免实施偏离。*