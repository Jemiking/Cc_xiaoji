# 日期类型系统迁移计划

## 一、问题现状分析

### 1.1 当前问题
- **类型混乱**：项目中同时使用 `java.time.*` 和 `kotlinx.datetime.*` 两套日期时间API
- **频繁报错**：类型不匹配导致编译错误频发
- **转换分散**：日期转换逻辑散布在各个模块中
- **维护困难**：没有统一的转换标准，每个开发者可能使用不同方式

### 1.2 影响范围评估
经过分析，以下模块受影响：
- `core/database`：实体类使用 `kotlinx.datetime`
- `feature/*/api`：API接口混用两种类型
- `app/domain`：业务逻辑中大量类型转换
- `app/presentation`：UI层需要格式化显示

### 1.3 风险评估
- **高风险**：数据库迁移可能影响数据完整性
- **中风险**：API变更可能导致功能异常
- **低风险**：UI层修改相对独立

## 二、迁移目标

### 2.1 短期目标（1周）
- 建立统一的日期转换层
- 修复当前编译错误
- 制定日期使用规范

### 2.2 中期目标（2-3周）
- 统一所有API接口的日期类型
- 迁移核心业务逻辑
- 更新单元测试

### 2.3 长期目标（1个月）
- 完成所有模块迁移
- 建立自动化检查机制
- 完善开发文档

## 三、技术方案设计

### 3.1 类型选择策略
```
推荐使用规则：
- 数据库层：使用 kotlinx.datetime（Room支持更好）
- API接口层：使用 java.time（兼容性更好）
- 业务逻辑层：根据上下文选择
- UI展示层：使用 java.time（Android原生支持）
```

### 3.2 转换器设计
```kotlin
// 放置在 core/common/src/main/kotlin/com/ccxiaoji/core/common/util/
package com.ccxiaoji.core.common.util

import kotlinx.datetime.*
import java.time.LocalDate as JavaLocalDate
import java.time.LocalDateTime as JavaLocalDateTime
import java.time.Instant as JavaInstant

/**
 * 统一的日期类型转换器
 * 负责处理 java.time 和 kotlinx.datetime 之间的转换
 */
object DateConverter {
    
    // LocalDate 转换
    fun toKotlinDate(date: JavaLocalDate): LocalDate {
        return LocalDate(date.year, date.monthValue, date.dayOfMonth)
    }
    
    fun toJavaDate(date: LocalDate): JavaLocalDate {
        return JavaLocalDate.of(date.year, date.monthNumber, date.dayOfMonth)
    }
    
    // LocalDateTime 转换
    fun toKotlinDateTime(dateTime: JavaLocalDateTime): LocalDateTime {
        return LocalDateTime(
            dateTime.year,
            dateTime.monthValue,
            dateTime.dayOfMonth,
            dateTime.hour,
            dateTime.minute,
            dateTime.second,
            dateTime.nano
        )
    }
    
    fun toJavaDateTime(dateTime: LocalDateTime): JavaLocalDateTime {
        return JavaLocalDateTime.of(
            dateTime.year,
            dateTime.monthNumber,
            dateTime.dayOfMonth,
            dateTime.hour,
            dateTime.minute,
            dateTime.second,
            dateTime.nanosecond
        )
    }
    
    // Instant 转换
    fun toKotlinInstant(instant: JavaInstant): Instant {
        return Instant.fromEpochMilliseconds(instant.toEpochMilli())
    }
    
    fun toJavaInstant(instant: Instant): JavaInstant {
        return JavaInstant.ofEpochMilli(instant.toEpochMilliseconds())
    }
}
```

### 3.3 数据映射器模板
```kotlin
// 每个模块创建自己的数据映射器
object ScheduleDataMapper {
    fun mapApiToExport(api: ScheduleInfo): ScheduleExportData {
        return ScheduleExportData(
            date = DateConverter.toKotlinDate(api.date),
            // ... 其他字段映射
        )
    }
}
```

## 四、具体实施步骤

### 第一阶段：基础设施建设（第1周）

#### 4.1 创建转换器（第1天）✅
- [x] 在 `core/common` 模块创建 `DateConverter`
- [x] 添加单元测试确保转换正确性
- [x] 更新模块依赖
- [x] 修复边界条件问题（00:00到00:00返回24小时）
- [x] 创建 `WorkHoursCalculator` 专门处理排班工时

**发现的问题**：
1. 边界条件处理：相同时间需要表示24小时班次
2. 分钟为负数时的计算错误
3. 需要业务特定的计算逻辑

**解决方案**：
- 采用最小改动原则，仅修复特定边界条件
- 创建专门的工具类隔离业务逻辑
- 增加完整的测试覆盖

#### 4.2 修复当前编译错误（第2天）✅
- [x] 使用转换器修复 `ExportToExcelUseCase`
- [x] 验证编译通过
- [x] 运行相关功能测试

**完成的修复**：
1. 使用 DateConverter.toJavaDate() 转换日期类型
2. 修正 duration 字段类型：String → Double
3. 修正 note 字段值：空字符串 → null

#### 4.3 创建数据映射器（第3-4天）✅
- [x] 为每个功能模块创建专属映射器
  - [x] ScheduleDataMapper
  - [x] LedgerDataMapper
  - [x] TodoDataMapper
  - [x] HabitDataMapper
- [x] 添加映射器单元测试

**完成的工作**：
1. 创建四个数据映射器，统一处理数据转换逻辑
2. 添加ScheduleDataMapper完整单元测试
3. 更新ExportToExcelUseCase使用映射器替代直接转换
4. 实现了关注点分离，提高代码可维护性

#### 4.4 制定编码规范（第5天）✅
- [x] 更新 CLAUDE.md 添加日期使用规范
- [x] 创建代码示例
- [x] 团队内部评审

### 第二阶段：核心模块迁移（第2-3周）

#### 4.5 API层迁移（第2周）
按优先级迁移各模块API：
- [x] LedgerApi（高优先级，使用最频繁）✅
  - API接口改为java.time类型
  - 实现类添加DateConverter转换
  - Repository层修复导入和转换
  - Presentation层统一使用java.time
- [ ] TodoApi（中优先级）
- [ ] HabitApi（中优先级）
- [ ] ScheduleApi（低优先级）

#### 4.6 业务逻辑层迁移（第3周）
- [ ] UseCase层统一使用转换器
- [ ] ViewModel层适配
- [ ] Repository层边界处理

### 第三阶段：全面迁移（第4周）

#### 4.7 数据库层评估
- [ ] 评估是否需要迁移数据库日期类型
- [ ] 如需迁移，创建数据库迁移脚本
- [ ] 测试数据完整性

#### 4.8 UI层统一
- [ ] 统一日期格式化工具
- [ ] 更新所有日期显示组件
- [ ] 确保用户体验一致

### 第四阶段：质量保证（持续）

#### 4.9 自动化检查
- [ ] 配置 Lint 规则检查日期使用
- [ ] 添加 CI/CD 检查
- [ ] 代码审查清单更新

#### 4.10 文档完善
- [ ] 更新开发文档
- [ ] 添加最佳实践示例
- [ ] 记录常见问题解决方案

## 五、迁移检查清单

### 5.1 每个模块迁移前
- [ ] 识别所有日期类型使用位置
- [ ] 评估影响范围
- [ ] 创建测试用例
- [ ] 备份关键数据

### 5.2 迁移过程中
- [ ] 使用统一转换器
- [ ] 保持功能不变
- [ ] 逐步迁移，小步提交
- [ ] 每步都要编译验证

### 5.3 迁移完成后
- [ ] 运行所有测试
- [ ] 功能回归测试
- [ ] 性能测试
- [ ] 更新文档

## 六、风险控制措施

### 6.1 数据安全
- 迁移前备份数据库
- 保留原始日期字段（如需要）
- 分批次迁移数据

### 6.2 功能稳定性
- 灰度发布策略
- A/B测试验证
- 快速回滚机制

### 6.3 团队协作
- 每日同步进度
- 及时沟通问题
- 知识分享会议

## 七、时间线

```
第1周：基础设施建设
├── Day 1：创建DateConverter
├── Day 2：修复编译错误
├── Day 3-4：创建数据映射器
└── Day 5：制定规范

第2周：API层迁移
├── Day 1-2：LedgerApi
├── Day 3：TodoApi
├── Day 4：HabitApi
└── Day 5：ScheduleApi

第3周：业务逻辑迁移
├── Day 1-2：UseCase层
├── Day 3-4：ViewModel层
└── Day 5：Repository层

第4周：全面迁移与测试
├── Day 1-2：数据库评估
├── Day 3-4：UI层统一
└── Day 5：集成测试
```

## 八、成功标准

1. **技术指标**
   - 零日期类型编译错误
   - 所有测试通过
   - 性能无明显下降

2. **质量指标**
   - 代码可读性提升
   - 维护成本降低
   - 新功能开发效率提高

3. **团队指标**
   - 所有成员掌握规范
   - 文档完整清晰
   - 知识传承到位

## 九、后续优化

1. **监控告警**
   - 建立日期异常监控
   - 设置性能基准线
   - 定期审查使用情况

2. **持续改进**
   - 收集使用反馈
   - 优化转换性能
   - 更新最佳实践

3. **技术演进**
   - 关注Kotlin新特性
   - 评估新的日期库
   - 保持技术先进性

---

**文档版本**：1.0  
**创建日期**：2025-01-14  
**最后更新**：2025-01-14  
**负责人**：开发团队  
**状态**：待执行