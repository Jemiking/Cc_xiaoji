# 版本目录迁移执行手册

## 📋 概述
本手册为版本目录迁移提供精确的执行指导，确保迁移过程不跑偏、不出错、可追溯。

**核心原则**：只改版本引用，不碰业务逻辑。

## 🎯 成功标准与失败标准

### ✅ 成功标准
1. **版本管理**
   - 100%模块使用libs.versions.toml
   - 0个硬编码版本号
   - 版本定义集中管理

2. **功能完整**
   - 所有模块编译成功
   - 所有测试通过
   - 构建时间≤25秒

3. **代码质量**
   - git diff只显示版本引用变化
   - 无业务逻辑改动
   - 无新增依赖

### ❌ 失败标准（立即停止）
- 任何模块编译失败
- 引入版本冲突
- 改变了import语句（除版本相关）
- 修改了非build.gradle.kts文件

## 📝 前置准备清单

```bash
# 1. 创建备份分支
git checkout -b backup/before-version-migration
git checkout feature/plan-module-migration

# 2. 确保干净的工作区
git status  # 应显示 "working tree clean"

# 3. 验证当前编译状态
./gradlew clean build --parallel

# 4. 记录当前依赖版本
./gradlew dependencies > dependencies-before.txt

# 5. 检查硬编码版本分布
rg -t kotlin '"[0-9]+\.[0-9]+\.[0-9]+"' --glob '**/build.gradle.kts' > hardcoded-versions.txt
```

## 🔄 标准迁移流程（每个模块）

### Step 1: 读取和分析
```bash
# 1.1 查看当前build.gradle.kts
cat [module]/build.gradle.kts

# 1.2 识别所有硬编码版本
rg '"[0-9]+\.[0-9]+\.[0-9]+"' [module]/build.gradle.kts

# 1.3 列出所有依赖
# 记录格式：依赖名称 -> 当前版本 -> 目标引用
```

### Step 2: 版本映射表
创建映射关系，确保版本一致性：

| 硬编码值 | libs.versions.toml引用 | 说明 |
|---------|------------------------|------|
| "34" | libs.versions.compileSdk.get().toInt() | Android SDK |
| "26" | libs.versions.minSdk.get().toInt() | 最低SDK |
| "1.12.0" | libs.androidx.core.ktx | Core KTX |
| "2.7.0" | libs.androidx.lifecycle.* | Lifecycle |
| "2024.02.00" | platform(libs.compose.bom) | Compose BOM |
| "1.5.7" | libs.versions.compose.compiler.get() | Compose编译器 |

### Step 3: 执行替换

#### 3.1 Android配置部分
```kotlin
// ❌ 错误（硬编码）
android {
    compileSdk = 34
    
    defaultConfig {
        minSdk = 26
    }
}

// ✅ 正确（版本目录）
android {
    compileSdk = libs.versions.compileSdk.get().toInt()
    
    defaultConfig {
        minSdk = libs.versions.minSdk.get().toInt()
    }
}
```

#### 3.2 依赖部分
```kotlin
// ❌ 错误（硬编码）
dependencies {
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
}

// ✅ 正确（版本目录）
dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
}
```

#### 3.3 特殊情况处理

**平台依赖（BOM）**：
```kotlin
// 保持platform()包装
implementation(platform(libs.compose.bom))
```

**编译器插件**：
```kotlin
composeOptions {
    kotlinCompilerExtensionVersion = libs.versions.compose.compiler.get()
}
```

**KSP参数**：
```kotlin
ksp(libs.room.compiler)  // 不是 implementation
```

### Step 4: 验证检查

#### 4.1 语法验证
```bash
# 检查是否还有硬编码版本
rg '"[0-9]+\.[0-9]+\.[0-9]+"' [module]/build.gradle.kts

# 应该只剩下versionCode/versionName等应用版本
```

#### 4.2 编译验证
```bash
# 单模块编译
./gradlew :[module]:build

# 检查依赖解析
./gradlew :[module]:dependencies
```

#### 4.3 差异验证
```bash
# 确保只有版本引用变化
git diff [module]/build.gradle.kts

# 不应该看到：
# - import语句变化
# - 逻辑代码变化
# - 新增/删除依赖
```

### Step 5: 提交记录
```bash
# 每个模块独立提交
git add [module]/build.gradle.kts
git commit -m "refactor: 迁移[module]模块到版本目录

- 替换所有硬编码版本为libs.versions.toml引用
- 保持依赖版本不变
- 编译验证通过"
```

## 🚨 常见错误及解决方案

### 错误1：找不到版本引用
```
错误：Unresolved reference: libs
解决：确保模块应用了版本目录
```

### 错误2：类型不匹配
```
错误：Type mismatch: inferred type is String but Int was expected
解决：使用.toInt()转换
示例：libs.versions.compileSdk.get().toInt()
```

### 错误3：重复依赖
```
错误：Duplicate class found
解决：检查是否意外添加了重复依赖
```

### 错误4：版本冲突
```
错误：Conflicting versions
解决：确保libs.versions.toml中版本与原版本一致
```

## 📊 迁移进度追踪

使用此表格追踪进度：

```markdown
| 模块 | 开始时间 | 硬编码数 | 替换数 | 编译 | 测试 | 提交 | 完成时间 |
|------|---------|----------|--------|------|------|------|----------|
| shared-user | - | - | - | - | - | - | - |
| shared-sync | - | - | - | - | - | - | - |
| shared-backup | - | - | - | - | - | - | - |
| shared-notification | - | - | - | - | - | - | - |
| feature-plan | ✅ | 30+ | 30+ | ✅ | ✅ | ✅ | 已完成 |
```

## 🔄 回滚策略

如果任何步骤失败：

```bash
# 1. 立即停止
# 不要尝试"修复"，先回滚

# 2. 恢复模块
git checkout HEAD -- [module]/build.gradle.kts

# 3. 分析失败原因
# 记录在本文档的"问题记录"部分

# 4. 修正策略后重试
```

## 📝 执行检查清单（每个模块）

复制此清单，逐项勾选：

```
模块名称：_______________

准备阶段：
□ 当前分支正确（feature/plan-module-migration）
□ 工作区干净（git status）
□ 模块当前编译成功

分析阶段：
□ 读取build.gradle.kts
□ 列出所有硬编码版本
□ 创建版本映射表
□ 确认libs.versions.toml有对应条目

执行阶段：
□ 替换compileSdk/minSdk/targetSdk
□ 替换composeOptions
□ 替换所有implementation依赖
□ 替换所有ksp/kapt依赖
□ 处理platform依赖

验证阶段：
□ 无硬编码版本遗留（除versionCode/Name）
□ 模块编译成功
□ 依赖版本未变化
□ git diff只有版本引用变化

完成阶段：
□ git add只添加build.gradle.kts
□ commit信息符合规范
□ 更新进度追踪表
```

## 🚫 禁止事项

1. **禁止**同时迁移多个模块
2. **禁止**修改版本号（保持原版本）
3. **禁止**添加新依赖
4. **禁止**删除现有依赖
5. **禁止**修改依赖的group或artifact
6. **禁止**修改build.gradle.kts以外的文件

## 📋 问题记录

记录迁移过程中遇到的问题：

### 问题模板
```
时间：YYYY-MM-DD HH:MM
模块：module-name
问题：详细描述
原因：分析原因
解决：解决方案
```

## 🎯 最终验证

所有模块完成后：

```bash
# 1. 完整编译
./gradlew clean build --parallel

# 2. 运行所有测试
./gradlew test

# 3. 检查无硬编码版本
rg -t kotlin '"[0-9]+\.[0-9]+\.[0-9]+"' --glob '**/build.gradle.kts' | grep -v "versionCode\|versionName"

# 4. 对比依赖版本
./gradlew dependencies > dependencies-after.txt
diff dependencies-before.txt dependencies-after.txt
```

## 📚 参考示例

### shared-user模块预期改动示例
```kotlin
// Before
implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")

// After  
implementation(libs.lifecycle.viewmodel.ktx)
implementation(libs.kotlin.coroutines)
```

---
*本手册创建于：2025-06-28*  
*用途：确保版本目录迁移精确执行，避免跑偏*  
*维护：每次迁移后更新问题记录和经验总结*