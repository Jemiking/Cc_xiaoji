# 分类升级方案设计

> 创建日期：2025-07-05
> 目标：从8个分类升级到15个分类
> 挑战：避免重复创建，保持数据一致性

## 问题分析

### 当前状态
- 已有8个分类（方案一创建）
- 需要15个分类（完整版本）
- 缺少7个重要分类

### 技术障碍
1. **初始化检查逻辑**
   ```kotlin
   if (categories.isEmpty()) {
       // 只在完全没有分类时执行
   }
   ```
   
2. **UUID生成机制**
   - 每次都生成新的UUID
   - 无法识别"同名分类"
   
3. **数据库约束**
   - 只有ID主键约束
   - 没有(userId, name, type)唯一约束

## 可行方案

### 方案A：智能增量升级（推荐）
```kotlin
suspend fun upgradeDefaultCategories() {
    val existingCategories = categoryDao.getCategoriesByUser(userId).first()
    val existingNames = existingCategories.map { it.name to it.type }.toSet()
    
    val allDefaultCategories = listOf(
        // 完整的15个分类定义
    )
    
    // 只添加缺失的分类
    val missingCategories = allDefaultCategories.filter { category ->
        (category.name to category.type) !in existingNames
    }
    
    if (missingCategories.isNotEmpty()) {
        categoryDao.insertCategories(missingCategories)
    }
}
```

**优点**：
- ✅ 不会创建重复分类
- ✅ 保留用户已有数据
- ✅ 可多次安全执行

### 方案B：版本化升级
```kotlin
// 在SharedPreferences中记录分类版本
const val CATEGORY_VERSION_KEY = "default_category_version"
const val CURRENT_CATEGORY_VERSION = 2 // 15个分类版本

suspend fun checkAndUpgradeCategories() {
    val currentVersion = prefs.getInt(CATEGORY_VERSION_KEY, 0)
    
    when {
        currentVersion < 1 -> createInitialCategories() // 8个
        currentVersion < 2 -> addMissingCategories()   // +7个
    }
    
    prefs.putInt(CATEGORY_VERSION_KEY, CURRENT_CATEGORY_VERSION)
}
```

**优点**：
- ✅ 清晰的版本管理
- ✅ 支持未来扩展
- ✅ 可追踪升级历史

### 方案C：固定ID方案
```kotlin
object DefaultCategories {
    // 使用固定的UUID，而不是随机生成
    const val CATEGORY_FOOD_ID = "00000000-0000-0000-0000-000000000001"
    const val CATEGORY_TRANSPORT_ID = "00000000-0000-0000-0000-000000000002"
    // ...
    
    val ALL_CATEGORIES = listOf(
        CategoryEntity(
            id = CATEGORY_FOOD_ID, // 固定ID
            name = "餐饮",
            // ...
        )
    )
}
```

**优点**：
- ✅ ID可预测，便于管理
- ✅ 可以使用REPLACE策略
- ✅ 跨设备同步友好

## 推荐实施步骤

### 1. 立即修复（保持现状）
- 继续使用方案一的8个分类
- 不影响现有用户使用

### 2. 准备升级（1-2天）
- 实现方案A的智能增量升级
- 添加单元测试
- 测试各种升级场景

### 3. 发布升级（下个版本）
```kotlin
// 在CcXiaoJiApplication.onCreate()中
CoroutineScope(Dispatchers.IO).launch {
    // 现有逻辑...
    
    // 新增：检查并升级分类
    categoryRepository.upgradeDefaultCategories()
}
```

### 4. 长期优化
- 统一分类定义到Category.kt
- 添加数据库唯一约束
- 完善分类管理功能

## 数据迁移示例

```kotlin
// 需要添加的7个分类
val missingCategories = listOf(
    CategoryEntity(name = "医疗", icon = "🏥", type = "EXPENSE", ...),
    CategoryEntity(name = "教育", icon = "📚", type = "EXPENSE", ...),
    CategoryEntity(name = "居住", icon = "🏠", type = "EXPENSE", ...),
    CategoryEntity(name = "水电", icon = "💡", type = "EXPENSE", ...),
    CategoryEntity(name = "通讯", icon = "📱", type = "EXPENSE", ...),
    CategoryEntity(name = "投资", icon = "📈", type = "INCOME", ...),
    CategoryEntity(name = "兼职", icon = "💼", type = "INCOME", ...)
)
```

## 风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 重复分类 | 用户困惑 | 基于名称去重 |
| ID冲突 | 数据错误 | 使用UUID |
| 升级失败 | 功能受限 | 保留降级逻辑 |

## 总结

直接执行方案二会失败，因为初始化检查会阻止执行。需要实现智能增量升级机制，确保：
1. 不创建重复分类
2. 保留用户数据
3. 支持多次执行

推荐采用方案A（智能增量升级）配合版本管理，确保平滑过渡。

---
*设计时间：2025-07-05*