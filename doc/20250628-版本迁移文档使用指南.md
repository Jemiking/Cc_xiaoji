# 版本迁移文档使用指南

## 📚 文档体系总览

为确保版本目录迁移精确执行、不跑偏，我们创建了完整的文档体系：

### 1️⃣ 核心文档
| 文档名称 | 用途 | 何时使用 |
|---------|------|----------|
| **版本目录迁移执行手册** | 详细操作指南 | 开始迁移前通读 |
| **版本目录迁移快速检查卡** | 实操参考 | 迁移过程中随时查看 |
| **版本目录完整映射表** | 版本对应关系 | 遇到具体依赖时查找 |
| **版本迁移防跑偏检查清单** | 防止偏离目标 | 每5分钟自检一次 |
| **版本目录迁移必要性分析** | 理解为什么要做 | 需要说服他人时使用 |

### 2️⃣ 辅助工具
| 工具名称 | 用途 | 使用方法 |
|---------|------|----------|
| **verify-version-migration.sh** | 自动验证迁移正确性 | `./scripts/verify-version-migration.sh shared/user` |

## 🚀 推荐使用流程

### Step 1: 迁移前准备（10分钟）
1. 阅读**版本迁移防跑偏检查清单**，记住10条红线
2. 打印**版本目录迁移快速检查卡**，放在手边
3. 打开**版本目录完整映射表**，以备查找

### Step 2: 执行迁移（每模块20分钟）
1. 参照**版本目录迁移执行手册**的标准流程
2. 使用**快速检查卡**的5步骤执行
3. 遇到具体依赖，查**完整映射表**
4. 每5分钟看一次**防跑偏检查清单**

### Step 3: 验证结果（5分钟）
1. 运行验证脚本：`./scripts/verify-version-migration.sh [module]`
2. 检查是否符合**执行手册**中的成功标准
3. 确认没有触碰**防跑偏检查清单**的红线

## 📖 各文档使用场景

### 场景1：第一次执行迁移
```
必读顺序：
1. 版本目录迁移必要性分析（理解Why）
2. 版本目录迁移执行手册（理解How）
3. 版本迁移防跑偏检查清单（理解What Not）
```

### 场景2：实际操作时
```
手边必备：
1. 版本目录迁移快速检查卡（贴在显示器旁）
2. 版本目录完整映射表（浏览器打开）
3. 终端运行验证脚本
```

### 场景3：遇到问题时
```
查找顺序：
1. 先看快速检查卡的"红线规则"
2. 再查执行手册的"常见错误"
3. 最后看完整映射表确认版本
```

## 🎯 关键成功要素

### 1. 保持专注
- 每次只做一件事：替换版本引用
- 抵制"顺便"的诱惑
- 机械化执行，不要创新

### 2. 频繁验证
- 每个模块改完立即编译
- 使用自动化脚本验证
- 发现问题立即回滚

### 3. 详细记录
- 使用进度追踪表
- 记录遇到的问题
- 更新文档中的经验

## ⚡ 快速决策树

```
遇到问题？
├── 是版本映射问题？→ 查【完整映射表】
├── 是操作步骤问题？→ 查【执行手册】
├── 是担心跑偏？→ 查【防跑偏检查清单】
├── 需要快速参考？→ 查【快速检查卡】
└── 需要自动验证？→ 运行【验证脚本】
```

## 📝 使用建议

1. **打印材料**：
   - 打印"快速检查卡"贴在显示器旁
   - 打印"防跑偏检查清单"的10条红线

2. **浏览器标签**：
   - Tab 1: 完整映射表
   - Tab 2: 执行手册
   - Tab 3: libs.versions.toml

3. **终端窗口**：
   - 窗口1: 执行迁移命令
   - 窗口2: 运行验证脚本
   - 窗口3: 查看git diff

## 🏁 完成标志

当你能够回答以下所有问题为"是"时，迁移就成功了：
- [ ] 所有模块都使用版本目录了吗？
- [ ] 没有硬编码版本了吗？
- [ ] 所有模块都能编译吗？
- [ ] 没有改动业务代码吗？
- [ ] 依赖版本保持不变吗？

---
*使用本指南 + 完整文档体系 = 版本迁移成功保障*  
*记住：好的迁移是"无聊"的迁移*