# 2025-09-20 系统“截长屏”功能对齐指南（HyperOS/MIUI 兼容）

本文档明确在 Compose + Android 工程内实现“系统级长截屏（滚动截图）”的统一方案，确保后续页面按本规范改造即可具备良好的长截屏兼容性与可回退能力。

## 背景与目标
- 背景：纯 Compose 的滚动容器（LazyColumn/verticalScroll）在部分 HyperOS/MIUI 机型上无法被系统长截屏识别（OEM 侧多基于 View 白名单识别）。
- 目标：在不影响主流程与视觉的前提下，为关键页面提供可靠的系统长截屏能力；无法识别时保留“应用内导出长图”兜底。

## 总体方案
- 基线增强（全局）
  - 在 Activity 视图树遍历时，将 ComposeView 标记为可滚动容器，并启用嵌套滚动，提升识别概率。
  - 查找线索：搜索关键字 `isScrollContainer` 或 `setNestedScrollingEnabled`；应位于应用主 Activity 的视图初始化处。
- 互操作兼容容器（页面可选启用）
  - 在页面内容外层包一层 AndroidView + NestedScrollView + ComposeView，内部用 Column 组织“头部 + 列表”整体内容，使系统将其识别为标准可滚动 View。
  - 按设备与开关自动启用，仅对 HyperOS/MIUI（可扩展）生效，默认 Debug 开启、Release 可按需灰度。
  - 查找线索：页面源码中搜索 `AndroidView(` 且包含 `NestedScrollView`；或搜索 `LongShot`/`Interop`/`滚动截图` 等注释。
- 兜底能力
  - 页面内导出长图（不依赖系统），在系统长截屏不可用时作为稳定能力保留。
  - 查找线索：搜索方法名 `exportReportLongImage` 或 “导出/长图/scroll to image”等注释。

## 启用判定与工具
- 设备判定工具（模块：common 或 util）
  - 提供 `DeviceUtils.isHyperOSOrMIUI()`：根据系统属性与厂商信息判定是否为小米/Redmi/POCO/HyperOS/MIUI。
  - 提供 `DeviceUtils.isLongShotInteropRecommended(context)`：是否建议启用互操作容器（可扩展其它厂商判定）。
  - 查找线索：搜索类名 `DeviceUtils` 或方法名 `isLongShotInteropRecommended`。
- 变体与开关（建议）：
  - Debug：默认启用互操作容器（只在 HyperOS/MIUI 生效）。
  - Release：默认关闭，可通过远程配置/BuildConfig/灰度开关开启。

示例（页面内部）：
```kotlin
val ctx = LocalContext.current
val enableInterop = remember(ctx) { DeviceUtils.isLongShotInteropRecommended(ctx) && BuildConfig.DEBUG }
```

## 页面改造规范
1) 只保留一个滚动容器
- 页面顶层不得再额外套 View 滚动容器与 Compose 滚动容器重复；使用互操作容器时，头部与内容应一并置于内部 Column，外层不再重复渲染（避免“卡片重复”）。

2) 使用 AndroidView(factory + update) 而非仅 factory
- 互操作容器内部 Composition 必须随外部状态变化而更新，否则会出现“列表为空白”的现象。
- 正确做法：
```kotlin
AndroidView(
  factory = { context ->
    val scroll = NestedScrollView(context).apply {
      isFillViewport = true
      isVerticalScrollBarEnabled = true
      isScrollContainer = true
      ViewCompat.setNestedScrollingEnabled(this, true)
    }
    val compose = ComposeView(context)
    scroll.addView(compose, ViewGroup.LayoutParams(MATCH_PARENT, WRAP_CONTENT))
    scroll
  },
  update = { scroll ->
    val compose = scroll.getChildAt(0) as ComposeView
    compose.setContent {
      // 使用最新的状态渲染页面（头部 + 分组列表）
      PageContentHeader()
      PageContentGroupedList(items)
    }
  }
)
```

3) 列表内容组织
- 将 LazyColumn 内容转为“非 Lazy 的 Column + forEach”用于互操作容器；避免在互操作容器内再嵌套 Lazy 列表，以减少 OEM 识别失败概率。
- 大列表注意分页/分段渲染，避免一次性渲染过多造成内存压力。

4) Insets 与边距
- 使用 Scaffold 的 `paddingValues` 透传到内部 Column 的 padding，确保状态栏/导航栏避让一致。
- 避免外层与内层重复 padding 造成视觉偏差。

5) 交互一致性
- 互操作容器内的点击/长按/编辑/删除等交互需保持与原 Lazy 列表一致。
- 直接复用现有交易项/日期标题组件（如：StyleableComponentFactory）。

## 关键落点（不依赖固定路径）
- 全局滚动标记：在主 Activity 的 setContent 或初始化完成后，对视图树进行遍历并标记 ComposeView（搜索 `isScrollContainer`、`setNestedScrollingEnabled`）。
- 设备判定工具：统一在公共工具模块提供 `DeviceUtils`（搜索上述类名/方法名）。
- 互操作容器落点：在需要支持系统长截屏的页面中，新增 `AndroidView + NestedScrollView + ComposeView` 容器（搜索 `AndroidView(` 与 `NestedScrollView`）。
- 导出长图兜底：在需要导出的页面（如报表/统计），保留“应用内导出长图”的实现（搜索“导出长图/long image/export”）。

## 验收与测试
- 设备：HyperOS/MIUI（多机型），Android 12+ 其它厂商抽样。
- 用例：
  - 是否出现“滚动截图/长截屏”入口。
  - 是否能自动滚动至底部并完整拼接。
  - 无重复/错位/空白/裁切；沉浸/Insets 正常。
  - 列表较长时，性能可接受（必要时分页）。
- 失败处理：
  - 未出现入口：确认互操作容器是否启用；页面高度是否足够；必要时仅对该页面强制启用。
  - 拼接异常：排查内部是否嵌套了额外滚动容器/动画导致布局跳变；收窄动画时机或取消复杂过渡。

## 风险与回滚
- 风险：互操作容器下非 Lazy 渲染可能造成性能/内存压力，须控制列表项数量或分段渲染。
- 回滚：页面改造均在分支/开关控制下，关闭开关即可回退到原有 Lazy 列表实现。

## 开发指引（建议沉淀组件）
- 提取通用 `LongShotCompatContainer(enabled: Boolean, content: @Composable () -> Unit)` 组件封装上述 factory/update 模式与滚动标记；页面仅关注内容组合，降低重复工作量。
- 推荐将“页头 + 内容区”提取为纯 Compose 的 `PageContent()`，便于在 Lazy 与 互操作两种容器间切换。

## 后续计划
- 第一批覆盖：账本筛选结果页、分类管理页、设置页（滚动长度适中、改造风险小）。
- 第二批评估：其它包含长列表的业务页面，按性能与需求灰度启用。
- 长期：在 Release 环境按设备特征和在线指标动态开关；保留“应用内导出长图”作为兜底。

---
维护人：记账端/客户端组（与性能/测试协作）
版本：v1（2025-09-20）
