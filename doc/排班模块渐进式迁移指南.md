# 排班模块渐进式迁移指南

> ⚠️ **重要提醒**：每次执行迁移前必须阅读此文档，确保理解所有步骤和注意事项。

## 📋 迁移概述

本指南详细说明如何将独立开发的排班模块（Cc_xiaoji_paiban）迁移到CC小记主项目的模块化架构中。

### 关键信息
- **源项目路径**：`D:\kotlin\Cc_xiaoji_paiban`
- **目标模块路径**：`feature/schedule/`
- **预计时间**：4天
- **迁移策略**：渐进式分步迁移
- **风险等级**：低

### 架构要求（来自CLAUDE.md）
1. 领域驱动模块化架构：`app → feature → shared → core`
2. 禁止横向和反向依赖
3. 模块间通过API接口通信
4. 自动编译和错误修复

## 🚀 迁移前准备

### 1. 环境检查清单
- [ ] 确认主项目编译通过：`./gradlew build`
- [ ] 确认数据库版本为5（包含排班表）
- [ ] 备份当前代码：`git add -A && git commit -m "备份：排班模块迁移前状态"`
- [ ] 创建迁移分支：`git checkout -b feature/schedule-migration`
- [ ] 确认排班模块源代码完整性

### 2. 依赖映射表
```
排班模块依赖 → 主项目依赖
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ScheduleDatabase     → CcDatabase
Theme/Color/Type     → com.ccxiaoji.core.ui.theme.*
ThemeManager        → 删除（使用主项目DataStore）
DatePickerDialog    → 评估后选择最佳实现
SyncStatus (Int)    → SyncStatus (枚举)
包名前缀            → com.ccxiaoji.feature.schedule
```

### 3. 关键差异处理方案
| 差异项 | 排班模块 | 主项目 | 处理方案 |
|--------|----------|--------|----------|
| 数据库版本 | v2 | v5 | 直接使用v5，无需迁移 |
| SyncStatus | Int (0/1) | 枚举 | 创建转换函数 |
| 日期存储 | Long | Long | 保持一致 |
| 主题管理 | 独立ThemeManager | DataStore | 适配主项目方式 |

## 📝 第一阶段：基础架构准备（第1天上午）

### 步骤1.1：创建模块结构
```bash
# 确保在主项目根目录
cd /mnt/d/kotlin/Cc_xiaoji

# feature/schedule目录应该已存在，检查结构
ls -la feature/schedule/
```

### 步骤1.2：配置API模块
```bash
# 1. 检查build.gradle.kts配置
cat feature/schedule/api/build.gradle.kts

# 2. 迁移API接口
cp /mnt/d/kotlin/Cc_xiaoji_paiban/app/src/main/java/com/example/cc_xiaoji/api/ScheduleApi.kt \
   feature/schedule/api/src/main/kotlin/com/ccxiaoji/feature/schedule/api/

# 3. 创建导航接口
```

**创建ScheduleNavigator.kt：**
```kotlin
package com.ccxiaoji.feature.schedule.api

import java.time.LocalDate

interface ScheduleNavigator {
    fun navigateToScheduleHome()
    fun navigateToShiftManage()
    fun navigateToScheduleEdit(date: LocalDate? = null)
    fun navigateToSchedulePattern()
    fun navigateToScheduleStatistics()
    fun navigateToExport()
    fun navigateToSettings()
}
```

### 步骤1.3：调整包名和导入
```bash
# 批量替换包名脚本
find feature/schedule/api -name "*.kt" -type f -exec sed -i \
    's/com.example.cc_xiaoji/com.ccxiaoji.feature.schedule/g' {} \;

# 编译检查
./gradlew :feature:schedule:api:compileDebugKotlin
```

### 验证检查点 ✅
- [ ] API模块编译通过
- [ ] ScheduleApi接口定义完整
- [ ] ScheduleNavigator接口创建
- [ ] 包名全部更新正确

## 📝 第二阶段：Domain层迁移（第1天下午）

### 步骤2.1：迁移领域模型
```bash
# 1. 创建目录结构
mkdir -p feature/schedule/domain/src/main/kotlin/com/ccxiaoji/feature/schedule/domain/{model,repository,usecase}

# 2. 复制模型类
cp /mnt/d/kotlin/Cc_xiaoji_paiban/app/src/main/java/com/example/cc_xiaoji/domain/model/*.kt \
   feature/schedule/domain/src/main/kotlin/com/ccxiaoji/feature/schedule/domain/model/

# 3. 调整包名
find feature/schedule/domain -name "*.kt" -type f -exec sed -i \
    's/com.example.cc_xiaoji/com.ccxiaoji.feature.schedule/g' {} \;
```

### 步骤2.2：迁移Repository接口
```kotlin
// 在 domain/repository/ScheduleRepository.kt
package com.ccxiaoji.feature.schedule.domain.repository

import kotlinx.coroutines.flow.Flow
import com.ccxiaoji.core.common.result.Result
import java.time.LocalDate

interface ScheduleRepository {
    fun getSchedulesByMonth(year: Int, month: Int): Flow<List<Schedule>>
    suspend fun getScheduleByDate(date: LocalDate): Schedule?
    suspend fun createSchedule(schedule: Schedule): Result<Unit>
    suspend fun updateSchedule(schedule: Schedule): Result<Unit>
    suspend fun deleteSchedule(id: Long): Result<Unit>
    
    fun getAllShifts(): Flow<List<Shift>>
    suspend fun getShiftById(id: Long): Shift?
    suspend fun createShift(shift: Shift): Result<Unit>
    suspend fun updateShift(shift: Shift): Result<Unit>
    suspend fun deleteShift(id: Long): Result<Unit>
}
```

### 步骤2.3：迁移UseCase（按优先级）
```bash
# 核心UseCase优先迁移顺序：
# 1. GetScheduleByDateUseCase
# 2. CreateScheduleUseCase
# 3. GetMonthScheduleUseCase
# 4. GetShiftsUseCase
# 5. ManageShiftUseCase
# 6. 其他UseCase

# 复制并调整
cp /mnt/d/kotlin/Cc_xiaoji_paiban/app/src/.../usecase/*.kt \
   feature/schedule/domain/src/.../usecase/
```

**注意事项：**
- 使用主项目的Result包装类：`com.ccxiaoji.core.common.result.Result`
- 调整依赖注入：确保使用`@Inject constructor`

### 验证检查点 ✅
- [ ] Domain模块编译通过
- [ ] 所有模型类迁移完成
- [ ] Repository接口定义完整
- [ ] 核心UseCase迁移并编译通过

## 📝 第三阶段：Data层实现（第2天）

### 步骤3.1：实现DAO扩展
```kotlin
// 注意：不需要迁移Entity，使用主项目core/database中的
// 在 feature/schedule/data/src/.../local/dao/ScheduleDaoExtensions.kt

package com.ccxiaoji.feature.schedule.data.local.dao

import com.ccxiaoji.core.database.dao.ScheduleDao
import com.ccxiaoji.core.database.entity.ScheduleEntity
import kotlinx.coroutines.flow.Flow
import java.time.LocalDate

// 扩展主项目的DAO，添加特定查询
suspend fun ScheduleDao.getSchedulesByDateRange(
    startDate: LocalDate,
    endDate: LocalDate
): List<ScheduleEntity> {
    return getSchedulesBetweenDates(
        startDate.toEpochDay() * 86400000,
        endDate.toEpochDay() * 86400000
    )
}
```

### 步骤3.2：实现Repository
```kotlin
// 在 feature/schedule/data/src/.../repository/ScheduleRepositoryImpl.kt
package com.ccxiaoji.feature.schedule.data.repository

import com.ccxiaoji.core.database.dao.ScheduleDao
import com.ccxiaoji.core.database.dao.ShiftDao
import com.ccxiaoji.core.database.model.SyncStatus
import com.ccxiaoji.feature.schedule.domain.repository.ScheduleRepository
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ScheduleRepositoryImpl @Inject constructor(
    private val scheduleDao: ScheduleDao,
    private val shiftDao: ShiftDao
) : ScheduleRepository {
    
    // 实现时注意类型转换
    private fun Int.toSyncStatus(): SyncStatus = when(this) {
        0 -> SyncStatus.LOCAL
        1 -> SyncStatus.SYNCED
        else -> SyncStatus.LOCAL
    }
    
    // 实现所有接口方法...
}
```

### 步骤3.3：创建数据模块配置
```kotlin
// 在 feature/schedule/data/src/.../di/ScheduleDataModule.kt
package com.ccxiaoji.feature.schedule.data.di

import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object ScheduleDataModule {
    
    @Provides
    @Singleton
    fun provideScheduleRepository(
        scheduleDao: ScheduleDao,
        shiftDao: ShiftDao
    ): ScheduleRepository = ScheduleRepositoryImpl(scheduleDao, shiftDao)
}
```

### 步骤3.4：迁移Worker（通知功能）
```bash
# 复制Worker类
cp /mnt/d/kotlin/Cc_xiaoji_paiban/app/src/.../notification/ScheduleNotificationWorker.kt \
   feature/schedule/data/src/.../worker/

# 调整包名和依赖
# 注意：使用 @HiltWorker 注解
```

### 验证检查点 ✅
- [ ] Data模块编译通过
- [ ] Repository实现完整
- [ ] 类型转换函数正确
- [ ] Worker配置正确

## 📝 第四阶段：Presentation层迁移（第3天）

### 步骤4.1：迁移ViewModel（按优先级）
```bash
# 迁移顺序：
# 1. CalendarViewModel（核心）
# 2. ShiftViewModel（班次管理）
# 3. ScheduleEditViewModel（编辑）
# 4. 其他ViewModel

# 复制文件
cp -r /mnt/d/kotlin/Cc_xiaoji_paiban/app/src/.../viewmodel/*.kt \
   feature/schedule/presentation/src/.../viewmodel/
```

**ViewModel调整要点：**
```kotlin
// 1. 继承主项目的BaseViewModel
import com.ccxiaoji.core.common.base.BaseViewModel

// 2. 使用正确的注解
@HiltViewModel
class CalendarViewModel @Inject constructor(
    private val getMonthScheduleUseCase: GetMonthScheduleUseCase
) : BaseViewModel() {
    // 实现...
}
```

### 步骤4.2：迁移UI组件
```bash
# 1. 评估组件冲突
# 主项目已有：ColorPicker、IconPicker等
# 排班特有：QuickShiftSelector、CalendarView

# 2. 迁移特有组件
mkdir -p feature/schedule/presentation/src/.../ui/components
cp QuickShiftSelector.kt CalendarView.kt → .../ui/components/

# 3. 迁移自定义日期选择器（如果比主项目的更好）
# 评估后决定是否保留
```

### 步骤4.3：迁移Screen
```kotlin
// 调整主题引用
import com.ccxiaoji.core.ui.theme.*

// 替换导航
@Composable
fun CalendarScreen(
    navigator: ScheduleNavigator, // 使用接口导航
    viewModel: CalendarViewModel = hiltViewModel()
) {
    // 保持原有UI逻辑
    // 替换主题引用
}
```

### 步骤4.4：创建模块导航
```kotlin
// 在 feature/schedule/presentation/src/.../navigation/ScheduleNavigation.kt
package com.ccxiaoji.feature.schedule.presentation.navigation

fun NavGraphBuilder.scheduleGraph(
    navController: NavController
) {
    navigation(
        startDestination = ScheduleScreen.Calendar.route,
        route = "schedule_graph"
    ) {
        composable(ScheduleScreen.Calendar.route) {
            CalendarScreen()
        }
        // 其他路由...
    }
}
```

### 验证检查点 ✅
- [ ] Presentation模块编译通过
- [ ] 所有ViewModel迁移完成
- [ ] UI组件冲突已解决
- [ ] 导航配置完整

## 📝 第五阶段：集成和测试（第4天）

### 步骤5.1：实现模块API和导航
```kotlin
// 1. 在 app/src/.../di/ScheduleBridgeModuleImpl.kt
@Singleton
class ScheduleApiImpl @Inject constructor(
    private val repository: ScheduleRepository,
    private val navigator: ScheduleNavigator
) : ScheduleApi {
    override suspend fun getTodaySchedule(): ScheduleInfo? {
        // 实现...
    }
}

// 2. 实现导航
@Singleton
class ScheduleNavigatorImpl @Inject constructor(
    private val navController: NavController
) : ScheduleNavigator {
    override fun navigateToScheduleHome() {
        navController.navigate("schedule_calendar")
    }
}
```

### 步骤5.2：更新主项目集成点
```kotlin
// 1. 在 MainActivity
setContent {
    CcXiaojiTheme {
        // 添加排班模块路由
    }
}

// 2. 在 BottomNavBar
NavigationBarItem(
    icon = { Icon(Icons.Default.CalendarToday, contentDescription = null) },
    label = { Text("排班") },
    selected = currentRoute == Screen.Schedule.route,
    onClick = { navController.navigate(Screen.Schedule.route) }
)

// 3. 在 HomeScreen 添加今日排班卡片
@Composable
fun TodayScheduleCard(scheduleApi: ScheduleApi) {
    // 显示今日排班信息
}
```

### 步骤5.3：依赖注入配置
```kotlin
// 在 app/src/.../di/RepositoryModule.kt
@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {
    
    @Provides
    @Singleton
    fun provideScheduleApi(
        impl: ScheduleApiImpl
    ): ScheduleApi = impl
}
```

### 步骤5.4：全面测试
```bash
# 1. 编译整个项目
./gradlew clean build

# 2. 运行单元测试
./gradlew test

# 3. 安装并手动测试
./gradlew installDebug
```

### 验证检查点 ✅
- [ ] 整个项目编译通过
- [ ] 排班模块可以正常访问
- [ ] 所有核心功能正常工作
- [ ] 主题和样式统一

## 🔧 常见问题解决

### 1. 编译错误处理
```bash
# 自动修复import错误
./gradlew :feature:schedule:compileDebugKotlin --continue

# 查看详细错误
./gradlew :feature:schedule:compileDebugKotlin --stacktrace
```

### 2. 类型不匹配问题
```kotlin
// SyncStatus转换辅助函数
fun ScheduleEntity.toDomainModel(): Schedule {
    return Schedule(
        id = id,
        date = LocalDate.ofEpochDay(date / 86400000),
        syncStatus = when(syncStatus) {
            SyncStatus.LOCAL -> 0
            SyncStatus.SYNCED -> 1
        }
    )
}
```

### 3. 依赖冲突解决
```kotlin
// 在模块的build.gradle.kts中排除冲突
implementation(project(":core:database")) {
    exclude(group = "duplicate.group")
}
```

## 📋 迁移后清理工作

### 1. 代码清理
- [ ] 删除未使用的导入
- [ ] 移除调试代码
- [ ] 统一代码风格

### 2. 文档更新
- [ ] 更新README.md
- [ ] 更新架构文档
- [ ] 记录API使用说明

### 3. 性能优化
- [ ] 检查内存泄漏
- [ ] 优化数据库查询
- [ ] 减少不必要的重组

## ⏮️ 回滚方案

如果迁移过程中出现严重问题：

```bash
# 1. 保存当前工作
git stash

# 2. 回到迁移前状态
git checkout main

# 3. 删除迁移分支
git branch -D feature/schedule-migration

# 4. 重新评估迁移方案
```

## 📝 迁移完成标志

迁移成功的标准：
1. ✅ 所有模块编译通过
2. ✅ 功能测试全部通过
3. ✅ 代码审查无问题
4. ✅ 性能无明显下降
5. ✅ 文档更新完整

## 🎯 下一步行动

迁移完成后：
1. 合并到主分支
2. 通知团队成员
3. 监控线上表现
4. 收集用户反馈
5. 计划后续优化

---

**最后更新**：2025-06-12
**维护者**：Claude Code
**版本**：1.0