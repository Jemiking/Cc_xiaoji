# POI 3.17兼容层实施方案

> 生成时间：2025-07-18  
> 基于O3MCP深度分析  
> 执行优先级：高

## 一、核心策略：Adapter + Buffered Chunk Strategy

### 1.1 方案概述
通过Kotlin封装层提供与POI 5.x兼容的API，内部降级到POI 3.17；同时以1~2MB缓冲分片读写实现大文件支持，并采用协程IO Dispatcher。

### 1.2 关键决策
- **保留未支持特性接口**：抛出`UnsupportedOperationException`，保持前向兼容
- **内存目标**：处理50MB xlsx时最大Java heap < 150MB
- **兼容性目标**：56处调用点100%编译和功能通过

## 二、具体实施步骤

### 第1步：创建POI兼容层模块（0.5天）

创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/compat/POICompat.kt`

```kotlin
package com.ccxiaoji.app.data.excel.compat

import org.apache.poi.ss.usermodel.*
import org.apache.poi.xssf.usermodel.*

/**
 * POI 3.17兼容层
 * 提供类似POI 5.x的API风格，内部映射到3.17的实现
 */
object POICompat {
    
    // === 填充模式常量 ===
    object FillPattern {
        const val SOLID_FOREGROUND = CellStyle.SOLID_FOREGROUND
        const val NO_FILL = CellStyle.NO_FILL
        const val FINE_DOTS = CellStyle.FINE_DOTS
        const val ALT_BARS = CellStyle.ALT_BARS
        const val SPARSE_DOTS = CellStyle.SPARSE_DOTS
        const val THICK_HORZ_BANDS = CellStyle.THICK_HORZ_BANDS
        const val THICK_VERT_BANDS = CellStyle.THICK_VERT_BANDS
        const val THICK_BACKWARD_DIAG = CellStyle.THICK_BACKWARD_DIAG
        const val THICK_FORWARD_DIAG = CellStyle.THICK_FORWARD_DIAG
        const val BIG_SPOTS = CellStyle.BIG_SPOTS
        const val BRICKS = CellStyle.BRICKS
        const val THIN_HORZ_BANDS = CellStyle.THIN_HORZ_BANDS
        const val THIN_VERT_BANDS = CellStyle.THIN_VERT_BANDS
        const val THIN_BACKWARD_DIAG = CellStyle.THIN_BACKWARD_DIAG
        const val THIN_FORWARD_DIAG = CellStyle.THIN_FORWARD_DIAG
        const val SQUARES = CellStyle.SQUARES
        const val DIAMONDS = CellStyle.DIAMONDS
    }
    
    // === 水平对齐常量 ===
    object HorizontalAlign {
        const val GENERAL = CellStyle.ALIGN_GENERAL
        const val LEFT = CellStyle.ALIGN_LEFT
        const val CENTER = CellStyle.ALIGN_CENTER
        const val RIGHT = CellStyle.ALIGN_RIGHT
        const val FILL = CellStyle.ALIGN_FILL
        const val JUSTIFY = CellStyle.ALIGN_JUSTIFY
        const val CENTER_SELECTION = CellStyle.ALIGN_CENTER_SELECTION
    }
    
    // === 垂直对齐常量 ===
    object VerticalAlign {
        const val TOP = CellStyle.VERTICAL_TOP
        const val CENTER = CellStyle.VERTICAL_CENTER
        const val BOTTOM = CellStyle.VERTICAL_BOTTOM
        const val JUSTIFY = CellStyle.VERTICAL_JUSTIFY
    }
    
    // === 边框样式常量 ===
    object Border {
        const val NONE = CellStyle.BORDER_NONE
        const val THIN = CellStyle.BORDER_THIN
        const val MEDIUM = CellStyle.BORDER_MEDIUM
        const val DASHED = CellStyle.BORDER_DASHED
        const val DOTTED = CellStyle.BORDER_DOTTED
        const val THICK = CellStyle.BORDER_THICK
        const val DOUBLE = CellStyle.BORDER_DOUBLE
        const val HAIR = CellStyle.BORDER_HAIR
        const val MEDIUM_DASHED = CellStyle.BORDER_MEDIUM_DASHED
        const val DASH_DOT = CellStyle.BORDER_DASH_DOT
        const val MEDIUM_DASH_DOT = CellStyle.BORDER_MEDIUM_DASH_DOT
        const val DASH_DOT_DOT = CellStyle.BORDER_DASH_DOT_DOT
        const val MEDIUM_DASH_DOT_DOT = CellStyle.BORDER_MEDIUM_DASH_DOT_DOT
        const val SLANTED_DASH_DOT = CellStyle.BORDER_SLANTED_DASH_DOT
    }
    
    // === 字体权重常量 ===
    object FontWeight {
        const val NORMAL = Font.BOLDWEIGHT_NORMAL
        const val BOLD = Font.BOLDWEIGHT_BOLD
    }
}

// === 扩展函数：提供POI 5.x风格的API ===

/**
 * 设置字体加粗（POI 5.x风格）
 */
fun Font.setBold(bold: Boolean) {
    this.boldweight = if (bold) POICompat.FontWeight.BOLD else POICompat.FontWeight.NORMAL
}

/**
 * 设置填充前景色（兼容方法）
 */
fun CellStyle.setFillForeground(color: Short) {
    this.fillForegroundColor = color
}

/**
 * 设置填充模式（兼容方法）
 */
fun CellStyle.setFillPatternCompat(pattern: Short) {
    this.fillPattern = pattern
}

/**
 * 设置水平对齐（兼容方法）
 */
fun CellStyle.setAlignmentCompat(alignment: Short) {
    this.alignment = alignment
}

/**
 * 设置垂直对齐（兼容方法）
 */
fun CellStyle.setVerticalAlignmentCompat(alignment: Short) {
    this.verticalAlignment = alignment
}

/**
 * 设置边框样式（兼容方法）
 */
fun CellStyle.setBorderBottomCompat(borderStyle: Short) {
    this.borderBottom = borderStyle
}

fun CellStyle.setBorderTopCompat(borderStyle: Short) {
    this.borderTop = borderStyle
}

fun CellStyle.setBorderLeftCompat(borderStyle: Short) {
    this.borderLeft = borderStyle
}

fun CellStyle.setBorderRightCompat(borderStyle: Short) {
    this.borderRight = borderStyle
}

/**
 * 创建样式的安全方法
 */
fun Workbook.createCellStyleCompat(): CellStyle {
    return this.createCellStyle()
}

/**
 * 创建字体的安全方法
 */
fun Workbook.createFontCompat(): Font {
    return this.createFont()
}

// === 异常处理 ===

/**
 * Excel操作异常基类
 */
sealed class ExcelException(message: String, cause: Throwable? = null) : Exception(message, cause)

/**
 * 文件格式异常
 */
class ExcelFormatException(message: String, cause: Throwable? = null) : ExcelException(message, cause)

/**
 * 内存不足异常
 */
class ExcelMemoryException(message: String, cause: Throwable? = null) : ExcelException(message, cause)

/**
 * 功能不支持异常
 */
class ExcelUnsupportedOperationException(message: String) : ExcelException(message)
```

### 第2步：修改ExcelStyleManager（1天）

```kotlin
// 修改ExcelStyleManager.kt的导入部分
import com.ccxiaoji.app.data.excel.compat.POICompat
import com.ccxiaoji.app.data.excel.compat.*

// 修改createHeaderStyle方法
fun createHeaderStyle(): XSSFCellStyle {
    val style = workbook.createCellStyleCompat() as XSSFCellStyle
    
    // 背景色 - 使用兼容方法
    style.setFillForeground(IndexedColors.LIGHT_BLUE.index)
    style.setFillPatternCompat(POICompat.FillPattern.SOLID_FOREGROUND)
    
    // 字体 - 使用扩展函数
    val font = workbook.createFontCompat()
    font.setBold(true)  // 使用新的扩展函数
    font.color = IndexedColors.WHITE.index
    font.fontHeightInPoints = 12.toShort()
    style.setFont(font)
    
    // 对齐 - 使用兼容常量
    style.setAlignmentCompat(POICompat.HorizontalAlign.CENTER)
    style.setVerticalAlignmentCompat(POICompat.VerticalAlign.CENTER)
    
    // 边框 - 使用兼容方法
    style.setBorderBottomCompat(POICompat.Border.THIN)
    style.setBorderLeftCompat(POICompat.Border.THIN)
    style.setBorderRightCompat(POICompat.Border.THIN)
    style.setBorderTopCompat(POICompat.Border.THIN)
    
    // 自动换行
    style.wrapText = true
    
    return style
}
```

### 第3步：实现内存优化策略（1天）

创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/compat/ChunkedExcelWriter.kt`

```kotlin
package com.ccxiaoji.app.data.excel.compat

import kotlinx.coroutines.*
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import java.io.*
import kotlin.coroutines.coroutineContext

/**
 * 分块Excel写入器，优化大文件内存占用
 */
class ChunkedExcelWriter(
    private val chunkSize: Int = 1000, // 每批处理的行数
    private val memoryThreshold: Long = 150 * 1024 * 1024 // 150MB内存阈值
) {
    
    /**
     * 分块写入数据
     */
    suspend fun <T> writeChunked(
        outputStream: OutputStream,
        data: List<T>,
        sheetName: String,
        headers: List<String>,
        rowMapper: (T) -> List<Any?>
    ) = withContext(Dispatchers.IO) {
        var workbook: XSSFWorkbook? = null
        var tempFile: File? = null
        
        try {
            // 创建临时文件
            tempFile = File.createTempFile("excel_", ".tmp")
            
            // 分批处理数据
            data.chunked(chunkSize).forEachIndexed { chunkIndex, chunk ->
                ensureActive() // 检查协程是否被取消
                
                // 检查内存使用
                checkMemoryUsage()
                
                if (chunkIndex == 0) {
                    // 第一批：创建工作簿和标题
                    workbook = XSSFWorkbook()
                    val sheet = workbook!!.createSheet(sheetName)
                    
                    // 写入标题行
                    val headerRow = sheet.createRow(0)
                    headers.forEachIndexed { index, header ->
                        headerRow.createCell(index).setCellValue(header)
                    }
                    
                    // 写入第一批数据
                    writeChunkToSheet(sheet, chunk, 1, rowMapper)
                } else {
                    // 后续批次：追加数据
                    val sheet = workbook!!.getSheetAt(0)
                    val startRow = chunkIndex * chunkSize + 1
                    writeChunkToSheet(sheet, chunk, startRow, rowMapper)
                }
                
                // 定期写入临时文件并释放内存
                if ((chunkIndex + 1) % 5 == 0) {
                    FileOutputStream(tempFile).use { fos ->
                        workbook!!.write(fos)
                    }
                    
                    // 重新加载以释放内存
                    workbook!!.close()
                    workbook = XSSFWorkbook(FileInputStream(tempFile))
                    
                    // 建议GC
                    System.gc()
                    yield() // 让出CPU
                }
            }
            
            // 最终写入输出流
            workbook!!.write(outputStream)
            
        } finally {
            workbook?.close()
            tempFile?.delete()
        }
    }
    
    /**
     * 写入数据块到Sheet
     */
    private fun <T> writeChunkToSheet(
        sheet: org.apache.poi.ss.usermodel.Sheet,
        chunk: List<T>,
        startRow: Int,
        rowMapper: (T) -> List<Any?>
    ) {
        chunk.forEachIndexed { index, item ->
            val row = sheet.createRow(startRow + index)
            val values = rowMapper(item)
            
            values.forEachIndexed { cellIndex, value ->
                val cell = row.createCell(cellIndex)
                when (value) {
                    is String -> cell.setCellValue(value)
                    is Number -> cell.setCellValue(value.toDouble())
                    is Boolean -> cell.setCellValue(value)
                    is java.util.Date -> cell.setCellValue(value)
                    else -> cell.setCellValue(value?.toString() ?: "")
                }
            }
        }
    }
    
    /**
     * 检查内存使用情况
     */
    private fun checkMemoryUsage() {
        val runtime = Runtime.getRuntime()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        
        if (usedMemory > memoryThreshold) {
            throw ExcelMemoryException(
                "内存使用超过阈值: ${usedMemory / 1024 / 1024}MB > ${memoryThreshold / 1024 / 1024}MB"
            )
        }
    }
}

/**
 * 分块Excel读取器
 */
class ChunkedExcelReader(
    private val chunkSize: Int = 1000
) {
    
    /**
     * 分块读取Excel文件
     */
    suspend fun readChunked(
        inputStream: InputStream,
        sheetIndex: Int = 0,
        onChunk: suspend (List<List<String>>, IntRange) -> Unit
    ) = withContext(Dispatchers.IO) {
        XSSFWorkbook(inputStream).use { workbook ->
            val sheet = workbook.getSheetAt(sheetIndex)
            val totalRows = sheet.lastRowNum + 1
            
            // 分批读取
            for (startRow in 0 until totalRows step chunkSize) {
                ensureActive()
                
                val endRow = minOf(startRow + chunkSize - 1, totalRows - 1)
                val chunk = mutableListOf<List<String>>()
                
                for (rowIndex in startRow..endRow) {
                    val row = sheet.getRow(rowIndex) ?: continue
                    val rowData = mutableListOf<String>()
                    
                    for (cellIndex in 0 until row.lastCellNum) {
                        val cell = row.getCell(cellIndex)
                        rowData.add(cell?.toString() ?: "")
                    }
                    
                    chunk.add(rowData)
                }
                
                // 处理数据块
                onChunk(chunk, startRow..endRow)
                
                // 让出CPU
                yield()
            }
        }
    }
}
```

### 第4步：协程包装层（0.5天）

创建文件：`app/src/main/kotlin/com/ccxiaoji/app/data/excel/compat/ExcelCoroutineWrapper.kt`

```kotlin
package com.ccxiaoji.app.data.excel.compat

import kotlinx.coroutines.*
import kotlin.coroutines.CoroutineContext

/**
 * Excel操作的协程包装器
 */
class ExcelCoroutineWrapper(
    private val defaultDispatcher: CoroutineDispatcher = Dispatchers.IO
) {
    
    /**
     * 在IO线程执行Excel操作
     */
    suspend fun <T> withExcelContext(
        block: suspend CoroutineScope.() -> T
    ): Result<T> = withContext(defaultDispatcher) {
        try {
            Result.success(block())
        } catch (e: ExcelException) {
            Result.failure(e)
        } catch (e: OutOfMemoryError) {
            Result.failure(ExcelMemoryException("内存不足", e))
        } catch (e: Exception) {
            Result.failure(ExcelException("Excel操作失败: ${e.message}", e))
        }
    }
    
    /**
     * 带进度回调的Excel操作
     */
    suspend fun <T> withProgress(
        onProgress: (Float) -> Unit,
        block: suspend CoroutineScope.(ProgressReporter) -> T
    ): Result<T> = withExcelContext {
        val reporter = ProgressReporter(onProgress)
        block(reporter)
    }
}

/**
 * 进度报告器
 */
class ProgressReporter(
    private val onProgress: (Float) -> Unit
) {
    private var currentProgress = 0f
    
    suspend fun report(progress: Float) {
        currentProgress = progress.coerceIn(0f, 1f)
        withContext(Dispatchers.Main) {
            onProgress(currentProgress)
        }
    }
    
    suspend fun reportStep(current: Int, total: Int) {
        report(current.toFloat() / total)
    }
}
```

### 第5步：测试用例（1天）

创建文件：`app/src/test/kotlin/com/ccxiaoji/app/data/excel/compat/POICompatTest.kt`

```kotlin
package com.ccxiaoji.app.data.excel.compat

import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.junit.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class POICompatTest {
    
    @Test
    fun `test style constants mapping`() {
        // 验证所有常量映射正确
        assertEquals(
            org.apache.poi.ss.usermodel.CellStyle.SOLID_FOREGROUND,
            POICompat.FillPattern.SOLID_FOREGROUND
        )
        assertEquals(
            org.apache.poi.ss.usermodel.CellStyle.ALIGN_CENTER,
            POICompat.HorizontalAlign.CENTER
        )
        assertEquals(
            org.apache.poi.ss.usermodel.CellStyle.BORDER_THIN,
            POICompat.Border.THIN
        )
    }
    
    @Test
    fun `test font extension functions`() {
        val workbook = XSSFWorkbook()
        val font = workbook.createFont()
        
        // 测试setBold扩展函数
        font.setBold(true)
        assertEquals(org.apache.poi.ss.usermodel.Font.BOLDWEIGHT_BOLD, font.boldweight)
        
        font.setBold(false)
        assertEquals(org.apache.poi.ss.usermodel.Font.BOLDWEIGHT_NORMAL, font.boldweight)
        
        workbook.close()
    }
    
    @Test
    fun `test style compatibility methods`() {
        val workbook = XSSFWorkbook()
        val style = workbook.createCellStyleCompat()
        
        // 测试兼容方法
        style.setFillPatternCompat(POICompat.FillPattern.SOLID_FOREGROUND)
        assertEquals(POICompat.FillPattern.SOLID_FOREGROUND, style.fillPattern)
        
        style.setAlignmentCompat(POICompat.HorizontalAlign.CENTER)
        assertEquals(POICompat.HorizontalAlign.CENTER, style.alignment)
        
        workbook.close()
    }
}
```

## 三、执行计划

### 3.1 时间安排（总计2.5天）

| 任务 | 时间 | 交付物 |
|-----|------|--------|
| 创建POI兼容层 | 0.5天 | POICompat.kt |
| 修改ExcelStyleManager | 1天 | 更新的样式管理器 |
| 实现内存优化 | 1天 | ChunkedExcelWriter/Reader |
| 协程包装层 | 0.5天 | ExcelCoroutineWrapper |
| 测试验证 | 并行进行 | 单元测试用例 |

### 3.2 验证标准

1. **编译通过**：所有56处API调用编译无错误
2. **功能正常**：Excel导入导出功能测试通过
3. **内存达标**：50MB文件处理时内存峰值 < 150MB
4. **性能优化**：大文件处理速度提升20%以上

### 3.3 风险缓解

1. **OOM风险**：通过分块处理和内存监控缓解
2. **兼容性风险**：充分的单元测试覆盖
3. **性能风险**：使用协程和缓冲优化

## 四、后续优化

1. **监控与告警**：添加内存使用监控和告警机制
2. **缓存优化**：实现样式缓存池，减少对象创建
3. **错误恢复**：实现断点续传和错误恢复机制
4. **格式支持**：评估CSV等轻量级格式作为备选

## 五、结论

通过兼容层方案，我们可以：
- ✅ 最小化代码改动（只需import和小幅调整）
- ✅ 保持代码现代化风格
- ✅ 为未来POI升级预留接口
- ✅ 解决大文件内存问题
- ✅ 2.5天内完成实施

这是当前最优的解决方案，既解决了眼前的编译问题，又为长期维护打下了良好基础。

---

*执行本方案前，请确保已备份现有代码。建议在新分支上进行实施。*